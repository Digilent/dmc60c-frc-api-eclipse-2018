<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DMC60C API: DMC60LowLevel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DMC60C API
   </div>
   <div id="projectbrief">This is the C/C++ API for the DMC60C.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_d_m_c60_low_level.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_d_m_c60_low_level-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DMC60LowLevel Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Low Level DMC60C Interface.  
 <a href="class_d_m_c60_low_level.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a293daec4f3d41bb4d7a414cdf0cea151"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a293daec4f3d41bb4d7a414cdf0cea151">DMC60LowLevel</a> (int value=0, int verbose=0, constructortype type=constructortype::useDeviceNumber)</td></tr>
<tr class="memdesc:a293daec4f3d41bb4d7a414cdf0cea151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="class_d_m_c60_low_level.html" title="Low Level DMC60C Interface. ">DMC60LowLevel</a> object.  <a href="#a293daec4f3d41bb4d7a414cdf0cea151">More...</a><br /></td></tr>
<tr class="separator:a293daec4f3d41bb4d7a414cdf0cea151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70dea7eadd417e116b458a186736d31"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ac70dea7eadd417e116b458a186736d31">setDeviceNumber</a> (uint16_t newdevnum)</td></tr>
<tr class="memdesc:ac70dea7eadd417e116b458a186736d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the deviceNumber of the DMC60C.  <a href="#ac70dea7eadd417e116b458a186736d31">More...</a><br /></td></tr>
<tr class="separator:ac70dea7eadd417e116b458a186736d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a517b93f859045fa310fa0725a248d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a94a517b93f859045fa310fa0725a248d">getDeviceNumber</a> ()</td></tr>
<tr class="memdesc:a94a517b93f859045fa310fa0725a248d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the deviceNumber of the DMC60C.  <a href="#a94a517b93f859045fa310fa0725a248d">More...</a><br /></td></tr>
<tr class="separator:a94a517b93f859045fa310fa0725a248d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9df5e94868d569b7ed95380856494fa"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ad9df5e94868d569b7ed95380856494fa">setDeviceName</a> (char *szDevName, uint16_t cbName)</td></tr>
<tr class="memdesc:ad9df5e94868d569b7ed95380856494fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the deviceName of the DMC60C.  <a href="#ad9df5e94868d569b7ed95380856494fa">More...</a><br /></td></tr>
<tr class="separator:ad9df5e94868d569b7ed95380856494fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f5e1a5c2bed34444dfb53ed8a33b97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a28f5e1a5c2bed34444dfb53ed8a33b97">getDeviceName</a> (char *szNameBuf)</td></tr>
<tr class="memdesc:a28f5e1a5c2bed34444dfb53ed8a33b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the device name of the DMC60C.  <a href="#a28f5e1a5c2bed34444dfb53ed8a33b97">More...</a><br /></td></tr>
<tr class="separator:a28f5e1a5c2bed34444dfb53ed8a33b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64f9fea8911a687f4b913bd83ea17cc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#af64f9fea8911a687f4b913bd83ea17cc">getFWVerBoot</a> ()</td></tr>
<tr class="memdesc:af64f9fea8911a687f4b913bd83ea17cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bootloader firmware of the DMC60C.  <a href="#af64f9fea8911a687f4b913bd83ea17cc">More...</a><br /></td></tr>
<tr class="separator:af64f9fea8911a687f4b913bd83ea17cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ed7be48080a173974740add6095061"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ab3ed7be48080a173974740add6095061">getFWVerApp</a> ()</td></tr>
<tr class="memdesc:ab3ed7be48080a173974740add6095061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the application firmware of the DMC60C.  <a href="#ab3ed7be48080a173974740add6095061">More...</a><br /></td></tr>
<tr class="separator:ab3ed7be48080a173974740add6095061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c251a75c7acfabbaace31f171f7c63"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a98c251a75c7acfabbaace31f171f7c63">getImgType</a> ()</td></tr>
<tr class="memdesc:a98c251a75c7acfabbaace31f171f7c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently running image type (bootloader, application, or aux bootloader).  <a href="#a98c251a75c7acfabbaace31f171f7c63">More...</a><br /></td></tr>
<tr class="separator:a98c251a75c7acfabbaace31f171f7c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbfbaaeda4f2bb9aa6efc0809ca4604"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a7dbfbaaeda4f2bb9aa6efc0809ca4604">getSessId</a> ()</td></tr>
<tr class="memdesc:a7dbfbaaeda4f2bb9aa6efc0809ca4604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the session ID assigned to the DMC60C.  <a href="#a7dbfbaaeda4f2bb9aa6efc0809ca4604">More...</a><br /></td></tr>
<tr class="separator:a7dbfbaaeda4f2bb9aa6efc0809ca4604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92177b3bace9694d2f43cbd0fdb095fc"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a92177b3bace9694d2f43cbd0fdb095fc">fetchFWVer</a> ()</td></tr>
<tr class="memdesc:a92177b3bace9694d2f43cbd0fdb095fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the device's firmware version information. This includes application firmware revision, bootloader firmware revision, and the time of firmware image that is currently running. This information is stored in the private member DMCInfo, and can be read with the get commands.  <a href="#a92177b3bace9694d2f43cbd0fdb095fc">More...</a><br /></td></tr>
<tr class="separator:a92177b3bace9694d2f43cbd0fdb095fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb575b74dda8721e3f539078f22a453d"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#adb575b74dda8721e3f539078f22a453d">softReset</a> ()</td></tr>
<tr class="memdesc:adb575b74dda8721e3f539078f22a453d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the session ID assigned to the DMC60C.  <a href="#adb575b74dda8721e3f539078f22a453d">More...</a><br /></td></tr>
<tr class="separator:adb575b74dda8721e3f539078f22a453d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b22c50f3cff5c769b2122867f7f8dc"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a58b22c50f3cff5c769b2122867f7f8dc">flashLEDs</a> ()</td></tr>
<tr class="memdesc:a58b22c50f3cff5c769b2122867f7f8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flashes the LEDs on the DMC60C in a rainbow pattern for 5 seconds.  <a href="#a58b22c50f3cff5c769b2122867f7f8dc">More...</a><br /></td></tr>
<tr class="separator:a58b22c50f3cff5c769b2122867f7f8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b80857f9be78673c32ac7bbee465b75"><td class="memItemLeft" align="right" valign="top"><a id="a3b80857f9be78673c32ac7bbee465b75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a3b80857f9be78673c32ac7bbee465b75">setPIDSlot</a> (uint8_t slotNum)</td></tr>
<tr class="memdesc:a3b80857f9be78673c32ac7bbee465b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the active PID slot used by the DMC60C. <br /></td></tr>
<tr class="separator:a3b80857f9be78673c32ac7bbee465b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c71fe83b27877d5583fe5a8be28f60"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a14c71fe83b27877d5583fe5a8be28f60">configPID_RampRate</a> (uint8_t slot, uint32_t ramp, int tmsWait)</td></tr>
<tr class="memdesc:a14c71fe83b27877d5583fe5a8be28f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the closed loop ramp rate used by the specified closed loop profile slot. The closed loop ramp rate specifies the maximum number of throttle units the output can change by each time the control loop executes in closed loop control mode (Velocity, Position, or Current). For example, If the closed loop ramp rate is set to 1000 and the PID update function determines that the throttle should be increased by 5000 units then the immediate throttle increase will be limited to 1000 units. If the next PID Update doesnt change the target throttle output value, the throttle will be increased by another 1000 units the next time the control loop executes. This process will continue until the target throttle is reached or a new throttle value is calculated. The control loop executes once every 500 µs. Therefore, specifying a closed loop ramp rate of 16 would result in it taking approximately 1.02 seconds to go from 0% throttle (0) to 100% throttle (32767). Specifying a value of 0 for the closed loop ramp rate disables throttling and allows the output to be immediately set to the target value. This parameter is stored in nonvolatile memory and is preserved across power cycles.  <a href="#a14c71fe83b27877d5583fe5a8be28f60">More...</a><br /></td></tr>
<tr class="separator:a14c71fe83b27877d5583fe5a8be28f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d434505ed25e5033515d29b8c384963"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a3d434505ed25e5033515d29b8c384963">getPID_RampRate</a> (uint8_t slot, uint32_t *ramp, int tmsWait)</td></tr>
<tr class="memdesc:a3d434505ed25e5033515d29b8c384963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ramp rate value stored in the specified PID slot.  <a href="#a3d434505ed25e5033515d29b8c384963">More...</a><br /></td></tr>
<tr class="separator:a3d434505ed25e5033515d29b8c384963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d3201e352d9936ee1b17c8b619724a"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a37d3201e352d9936ee1b17c8b619724a">configPID_FwdMaxDuty</a> (uint8_t slot, int value, int tmsWait)</td></tr>
<tr class="memdesc:a37d3201e352d9936ee1b17c8b619724a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the closed loop control maximum forward duty cycle used by the specified motor control profile slot. The maximum forward duty cycle is the largest positive duty cycle that may be applied to the output when motor control profile slot 0 is specified in a control frame that specifies one of the closed loop control modes (Velocity, Position, or Current). The value specified for this parameter should be restricted to be within the range of 0 to 32767. This parameter is stored in nonvolatile memory and is preserved across power cycles.  <a href="#a37d3201e352d9936ee1b17c8b619724a">More...</a><br /></td></tr>
<tr class="separator:a37d3201e352d9936ee1b17c8b619724a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c96ecf46de14b27dd66b271bd5b810b"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a8c96ecf46de14b27dd66b271bd5b810b">getPID_FwdMaxDuty</a> (uint8_t slot, int *value, int tmsWait)</td></tr>
<tr class="memdesc:a8c96ecf46de14b27dd66b271bd5b810b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the forward max duty cycle stored in the specified PID slot.  <a href="#a8c96ecf46de14b27dd66b271bd5b810b">More...</a><br /></td></tr>
<tr class="separator:a8c96ecf46de14b27dd66b271bd5b810b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e317aaffe4fd7a78a0cb7f0719e7ff"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a99e317aaffe4fd7a78a0cb7f0719e7ff">configPID_RevMaxDuty</a> (uint8_t slot, int value, int tmsWait)</td></tr>
<tr class="memdesc:a99e317aaffe4fd7a78a0cb7f0719e7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the closed loop control maximum reverse duty cycle used by the specified motor control profile slot. The maximum reverse duty cycle is the largest negative duty cycle that may be applied to the output when motor control profile slot 0 is specified in a control frame that specifies one of the closed loop control modes (Velocity, Position, or Current). The value specified for this parameter should be restricted to be within the range of -32768 to 0. This parameter is stored in nonvolatile memory and is preserved across power cycles.  <a href="#a99e317aaffe4fd7a78a0cb7f0719e7ff">More...</a><br /></td></tr>
<tr class="separator:a99e317aaffe4fd7a78a0cb7f0719e7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a166312c6f384aa583dc64e2906d82d"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a7a166312c6f384aa583dc64e2906d82d">getPID_RevMaxDuty</a> (uint8_t slot, int *value, int tmsWait)</td></tr>
<tr class="memdesc:a7a166312c6f384aa583dc64e2906d82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reverse max duty cycle stored in the specified PID slot.  <a href="#a7a166312c6f384aa583dc64e2906d82d">More...</a><br /></td></tr>
<tr class="separator:a7a166312c6f384aa583dc64e2906d82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71427a94539baeb0bf6216b7e77273d0"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a71427a94539baeb0bf6216b7e77273d0">configPID_FwdNominal</a> (uint8_t slot, int value, int tmsWait)</td></tr>
<tr class="memdesc:a71427a94539baeb0bf6216b7e77273d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the closed loop control nominal forward duty cycle used by the specified motor control profile slot. The nominal forward duty cycle is the smallest positive duty cycle that may be applied to the output when the closed loop error exceeds the allowable closed loop error specified for the selected motor profile slot. The closed loop nominal forward duty cycle is only utilized when the control frame specifies one of the closed loop control modes (Velocity, Position, or Current). The value specified for this parameter should be restricted to be within the range of 0 to 32767. This parameter is stored in nonvolatile memory and is preserved across power cycles.  <a href="#a71427a94539baeb0bf6216b7e77273d0">More...</a><br /></td></tr>
<tr class="separator:a71427a94539baeb0bf6216b7e77273d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5af58cb93535d0ec94de50832135b2"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a5e5af58cb93535d0ec94de50832135b2">getPID_FwdNominal</a> (uint8_t slot, int *value, int tmsWait)</td></tr>
<tr class="memdesc:a5e5af58cb93535d0ec94de50832135b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the forward nominal duty cycle stored in the specified PID slot.  <a href="#a5e5af58cb93535d0ec94de50832135b2">More...</a><br /></td></tr>
<tr class="separator:a5e5af58cb93535d0ec94de50832135b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a56b1b380ab25e011139a45ed55969d"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a5a56b1b380ab25e011139a45ed55969d">configPID_RevNominal</a> (uint8_t slot, int value, int tmsWait)</td></tr>
<tr class="memdesc:a5a56b1b380ab25e011139a45ed55969d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the closed loop control nominal reverse duty cycle used by the specified motor control profile slot. The nominal reverse duty cycle is the smallest negative duty cycle that may be applied to the output when the closed loop error exceeds the allowable closed loop error specified for the selected motor profile slot. The closed loop nominal reverse duty cycle is only utilized when the control frame specifies one of the closed loop control modes (Velocity, Position, or Current). The value specified for this parameter should be restricted to be within the range of -32768 to 0. This parameter is stored in nonvolatile memory and is preserved across power cycles.  <a href="#a5a56b1b380ab25e011139a45ed55969d">More...</a><br /></td></tr>
<tr class="separator:a5a56b1b380ab25e011139a45ed55969d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8eba6c81857a24814b8d14be04f7f2"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a5d8eba6c81857a24814b8d14be04f7f2">getPID_RevNominal</a> (uint8_t slot, int *value, int tmsWait)</td></tr>
<tr class="memdesc:a5d8eba6c81857a24814b8d14be04f7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reverse nominal duty cycle stored in the specified PID slot.  <a href="#a5d8eba6c81857a24814b8d14be04f7f2">More...</a><br /></td></tr>
<tr class="separator:a5d8eba6c81857a24814b8d14be04f7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee68dbd074890f405226b7eb5679bdc6"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#aee68dbd074890f405226b7eb5679bdc6">configPID_kP</a> (uint8_t slot, float value, int tmsWait)</td></tr>
<tr class="memdesc:aee68dbd074890f405226b7eb5679bdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the proportional gain constant used by the specified motor control profile slot. This constant is used during closed loop control to calculate a proportional increase or decrease in the throttle (duty cycle) due to the measured closed loop error. This parameter will be utilized for PID calculations when motor control profile slot 1 is specified in a control frame that specifies one of the closed loop control modes (Velocity, Position, or Current). This parameter is stored in nonvolatile memory and is preserved across power cycles.  <a href="#aee68dbd074890f405226b7eb5679bdc6">More...</a><br /></td></tr>
<tr class="separator:aee68dbd074890f405226b7eb5679bdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594f412f085f2984f54aa31c58b394e8"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a594f412f085f2984f54aa31c58b394e8">get_kP</a> (uint8_t slot, float *value, int tmsWait)</td></tr>
<tr class="memdesc:a594f412f085f2984f54aa31c58b394e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the P gain value of the specified slot and stores the value into a pointer.  <a href="#a594f412f085f2984f54aa31c58b394e8">More...</a><br /></td></tr>
<tr class="separator:a594f412f085f2984f54aa31c58b394e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03819dfdc988e0cc03eca7b82b864203"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a03819dfdc988e0cc03eca7b82b864203">configPID_kI</a> (uint8_t slot, float value, int tmsWait)</td></tr>
<tr class="memdesc:a03819dfdc988e0cc03eca7b82b864203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the integral gain constant used by the specified motor control profile slot. This constant is used during closed loop control to calculate an integral increase or decrease in the throttle (duty cycle) due to the measured closed loop error. This parameter will be utilized for PID calculations when motor control profile slot 1 is specified in a control frame that specifies one of the closed loop control modes (Velocity, Position, or Current). This parameter is stored in nonvolatile memory and is preserved across power cycles.  <a href="#a03819dfdc988e0cc03eca7b82b864203">More...</a><br /></td></tr>
<tr class="separator:a03819dfdc988e0cc03eca7b82b864203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6747dd7282f8eb0fcc0bb2f5f7112e8"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#aa6747dd7282f8eb0fcc0bb2f5f7112e8">get_kI</a> (uint8_t slot, float *value, int tmsWait)</td></tr>
<tr class="memdesc:aa6747dd7282f8eb0fcc0bb2f5f7112e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the I gain value of the specified slot and stores the value into a pointer.  <a href="#aa6747dd7282f8eb0fcc0bb2f5f7112e8">More...</a><br /></td></tr>
<tr class="separator:aa6747dd7282f8eb0fcc0bb2f5f7112e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5017be8857d50f382506832785d0628c"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a5017be8857d50f382506832785d0628c">configPID_kD</a> (uint8_t slot, float value, int tmsWait)</td></tr>
<tr class="memdesc:a5017be8857d50f382506832785d0628c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the derivative gain constant used by the specified motor control profile slot. This constant is used during closed loop control to calculate the derivative increase or decrease in the throttle (duty cycle) due to the measured closed loop error. This parameter will be utilized for PID calculations when motor control profile slot 1 is specified in a control frame that specifies one of the closed loop control modes (Velocity, Position, or Current). This parameter is stored in nonvolatile memory and is preserved across power cycles.  <a href="#a5017be8857d50f382506832785d0628c">More...</a><br /></td></tr>
<tr class="separator:a5017be8857d50f382506832785d0628c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c37ab2b5cf7db4137b31d9d3848713d"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a9c37ab2b5cf7db4137b31d9d3848713d">get_kD</a> (uint8_t slot, float *value, int tmsWait)</td></tr>
<tr class="memdesc:a9c37ab2b5cf7db4137b31d9d3848713d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the D gain value of the specified slot and stores the value into a pointer.  <a href="#a9c37ab2b5cf7db4137b31d9d3848713d">More...</a><br /></td></tr>
<tr class="separator:a9c37ab2b5cf7db4137b31d9d3848713d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb93f89537ea0661a0eca9aea52674c8"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#acb93f89537ea0661a0eca9aea52674c8">configPID_kF</a> (uint8_t slot, float value, int tmsWait)</td></tr>
<tr class="memdesc:acb93f89537ea0661a0eca9aea52674c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the feed-forward gain constant used by the specified motor control profile slot. This constant is used during closed loop control to calculate the number of throttle units to contribute to the duty cycle as the proportion of the setpoint (target Velocity, Position, or Current) independent of the error. For example, if the target current is 20.0 amps and you want to apply 50% throttle for this setpoint then the feed forward gain would be set to (0.50×32767)/20.0=819.175. Convert this to fixed-point by multiplying by 65536. This results in a value of 0x03332CCC (hex), which is what should be sent to the DMC60 in the value field of the PARAMSET packet. The feed-forward term can be excluded from the PID calculations by specifying a value of 0 for the gain. This parameter will be utilized for PID calculations when motor control profile slot 1 is specified in a control frame that specifies one of the closed loop control modes (Velocity, Position, or Current). This parameter is stored in nonvolatile memory and is preserved across power cycles.  <a href="#acb93f89537ea0661a0eca9aea52674c8">More...</a><br /></td></tr>
<tr class="separator:acb93f89537ea0661a0eca9aea52674c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b3250aa373f7d310783e7823bb3fb8"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a68b3250aa373f7d310783e7823bb3fb8">get_kF</a> (uint8_t slot, float *value, int tmsWait)</td></tr>
<tr class="memdesc:a68b3250aa373f7d310783e7823bb3fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the F gain value of the specified slot and stores the value into a pointer.  <a href="#a68b3250aa373f7d310783e7823bb3fb8">More...</a><br /></td></tr>
<tr class="separator:a68b3250aa373f7d310783e7823bb3fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dc8ad4712d5ea17dfff8649e7ed37e"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#af2dc8ad4712d5ea17dfff8649e7ed37e">configPID_IZone</a> (uint8_t slot, unsigned int value, int tmsWait)</td></tr>
<tr class="memdesc:af2dc8ad4712d5ea17dfff8649e7ed37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the integral accumulator limit used by motor control profile slot 0. The integral accumulator limit, or I-zone, is used to limit how large the integral accumulator can grow during closed loop control. The value sent to the DMC60 is converted to a 32-bit signed integer and used to set the positive and negative bounds of the integral accumulator. If the integral accumulator exceeds these bounds while PID calculations are performed, then the accumulator will be capped to value or -value. This provides a mechanism for combating integral windup. Setting a value of 0 will disable the limit and allow the integral accumulator to grow without bounds. This parameter is stored in nonvolatile memory and is preserved across power cycles.  <a href="#af2dc8ad4712d5ea17dfff8649e7ed37e">More...</a><br /></td></tr>
<tr class="separator:af2dc8ad4712d5ea17dfff8649e7ed37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bb041176db71fb4150f08acef7d7ca"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ad5bb041176db71fb4150f08acef7d7ca">get_IZone</a> (uint8_t slot, unsigned int *value, int tmsWait)</td></tr>
<tr class="memdesc:ad5bb041176db71fb4150f08acef7d7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current Izone value stored in the specified PID slot.  <a href="#ad5bb041176db71fb4150f08acef7d7ca">More...</a><br /></td></tr>
<tr class="separator:ad5bb041176db71fb4150f08acef7d7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42175c4ddb198b062283e8d90c8727ae"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a42175c4ddb198b062283e8d90c8727ae">configPID_AllowableError</a> (uint8_t slot, uint32_t value, int tmsWait)</td></tr>
<tr class="memdesc:a42175c4ddb198b062283e8d90c8727ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the allowable closed loop error used by the specified motor control profile slot. The allowable closed loop error specifies the minimum error required for the PID controller to calculate a non-zero contribution to the output throttle (duty cycle) based on the P, I, and D terms. If the allowable error is set to a non-zero value and the measured error is less than the allowable error then the P, I, and D terms will contribute 0 throttle units to the output throttle calculation and the integral accumulator will be cleared. If the allowable error is set to 0 or the measured error exceeds the allowable error then P, I, and D terms are included in the output throttle calculation. The feed-forward gain constant, or F term, is included in the output throttle calculation regardless of the allowable error setting. This parameter will be utilized for PID calculations when motor control profile slot 1 is specified in a control frame that specifies one of the closed loop control modes (Velocity, Position, or Current). This parameter is stored in nonvolatile memory and is preserved across power cycles.  <a href="#a42175c4ddb198b062283e8d90c8727ae">More...</a><br /></td></tr>
<tr class="separator:a42175c4ddb198b062283e8d90c8727ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac470a2fbff00fef6783131d0c70f2efd"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ac470a2fbff00fef6783131d0c70f2efd">getPID_AllowableError</a> (uint8_t slot, uint32_t *value, int tmsWait)</td></tr>
<tr class="memdesc:ac470a2fbff00fef6783131d0c70f2efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the allowable error value stored in the specified PID slot.  <a href="#ac470a2fbff00fef6783131d0c70f2efd">More...</a><br /></td></tr>
<tr class="separator:ac470a2fbff00fef6783131d0c70f2efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9d7e3e415bf7e0326f87b017f11e49"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#afe9d7e3e415bf7e0326f87b017f11e49">configForwardLimitSwitchEnable</a> (bool enable, int tmsWait)</td></tr>
<tr class="memdesc:afe9d7e3e415bf7e0326f87b017f11e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the forward limit switch is enabled or not.  <a href="#afe9d7e3e415bf7e0326f87b017f11e49">More...</a><br /></td></tr>
<tr class="separator:afe9d7e3e415bf7e0326f87b017f11e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54ec2b582813688861a64ddec6afb89"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ac54ec2b582813688861a64ddec6afb89">getForwardLimitSwitchEnable</a> (bool *enable, int tmsWait)</td></tr>
<tr class="memdesc:ac54ec2b582813688861a64ddec6afb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not the forward limit switch is enabled or not.  <a href="#ac54ec2b582813688861a64ddec6afb89">More...</a><br /></td></tr>
<tr class="separator:ac54ec2b582813688861a64ddec6afb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce3872ba40adf4290ba5640236d2402"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a3ce3872ba40adf4290ba5640236d2402">configForwardLimitSwitchType</a> (bool normallyClosed, int tmsWait)</td></tr>
<tr class="memdesc:a3ce3872ba40adf4290ba5640236d2402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the switch type of the forward limit switch.  <a href="#a3ce3872ba40adf4290ba5640236d2402">More...</a><br /></td></tr>
<tr class="separator:a3ce3872ba40adf4290ba5640236d2402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59b0a6c9c06159cf5bafa76dba35ab5"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ae59b0a6c9c06159cf5bafa76dba35ab5">getForwardLimitSwitchType</a> (bool *normallyClosed, int tmsWait)</td></tr>
<tr class="memdesc:ae59b0a6c9c06159cf5bafa76dba35ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the switch type of the forward limit switch.  <a href="#ae59b0a6c9c06159cf5bafa76dba35ab5">More...</a><br /></td></tr>
<tr class="separator:ae59b0a6c9c06159cf5bafa76dba35ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8465082309c0ff51a0d6322f252cd7a"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ad8465082309c0ff51a0d6322f252cd7a">configReverseLimitSwitchEnable</a> (bool enable, int tmsWait)</td></tr>
<tr class="memdesc:ad8465082309c0ff51a0d6322f252cd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the reverse limit switch is enabled or not.  <a href="#ad8465082309c0ff51a0d6322f252cd7a">More...</a><br /></td></tr>
<tr class="separator:ad8465082309c0ff51a0d6322f252cd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1f29a8572547a18d343d0a192f67d6"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#acc1f29a8572547a18d343d0a192f67d6">getReverseLimitSwitchEnable</a> (bool *enable, int tmsWait)</td></tr>
<tr class="memdesc:acc1f29a8572547a18d343d0a192f67d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not the reverse limit switch is enabled or not.  <a href="#acc1f29a8572547a18d343d0a192f67d6">More...</a><br /></td></tr>
<tr class="separator:acc1f29a8572547a18d343d0a192f67d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bb7f1045f130b5a79b7bc02a8c611e"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a09bb7f1045f130b5a79b7bc02a8c611e">configReverseLimitSwitchType</a> (bool normallyClosed, int tmsWait)</td></tr>
<tr class="memdesc:a09bb7f1045f130b5a79b7bc02a8c611e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the switch type of the reverse limit switch.  <a href="#a09bb7f1045f130b5a79b7bc02a8c611e">More...</a><br /></td></tr>
<tr class="separator:a09bb7f1045f130b5a79b7bc02a8c611e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979429b016f5ce3b6d8b0551cd8db329"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a979429b016f5ce3b6d8b0551cd8db329">getReverseLimitSwitchType</a> (bool *normallyClosed, int tmsWait)</td></tr>
<tr class="memdesc:a979429b016f5ce3b6d8b0551cd8db329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the switch type of the reverse limit switch.  <a href="#a979429b016f5ce3b6d8b0551cd8db329">More...</a><br /></td></tr>
<tr class="separator:a979429b016f5ce3b6d8b0551cd8db329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b9d47a1de502bb8a653a54fae4639b"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ab3b9d47a1de502bb8a653a54fae4639b">configSoftFwdThreshold</a> (bool enable, int limit, int tmsWait)</td></tr>
<tr class="memdesc:ab3b9d47a1de502bb8a653a54fae4639b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the soft forward limit threshold. The soft forward limit threshold specifies the maximum position that the encoder can read in the forward direction. The units are native to the encoder thats connected to the expansion header. The DMC60s control loop runs every 500us. Each time it executes the current position of the encoder is read and compared to the soft forward limit threshold. If the encoders current position is greater than or equal to the specified soft forward limit threshold and the soft forward limit is enabled, then the DMC60s output will be prevented from applying a positive voltage to the load. Both positive and negative soft limit thresholds are valid. This parameter is stored in nonvolatile memory and is preserved across power cycles.  <a href="#ab3b9d47a1de502bb8a653a54fae4639b">More...</a><br /></td></tr>
<tr class="separator:ab3b9d47a1de502bb8a653a54fae4639b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c10dd21de40c0f19e3149e06e7e078"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a37c10dd21de40c0f19e3149e06e7e078">getSoftFwdThreshold</a> (bool *enable, int *limit, int tmsWait)</td></tr>
<tr class="memdesc:a37c10dd21de40c0f19e3149e06e7e078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current soft forward threshold value.  <a href="#a37c10dd21de40c0f19e3149e06e7e078">More...</a><br /></td></tr>
<tr class="separator:a37c10dd21de40c0f19e3149e06e7e078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b4df6835e63f2839aa7b9a0b97324b"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a14b4df6835e63f2839aa7b9a0b97324b">configSoftRevThreshold</a> (bool enable, int limit, int tmsWait)</td></tr>
<tr class="memdesc:a14b4df6835e63f2839aa7b9a0b97324b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the reverse limit switch type. The reverse limit switch be configured as a normally closed switch by setting the value field to a 1 or a normally open switch by setting the value field to a 0. The DMC60 uses internal (weak) pull-ups to pull the reverse limit switch pin to 3.3V. When configured as a normally closed switch the DMC60 will prevent the output from applying a negative voltage to the load when the limit switch opens, causing the DMC60 to detect a logic 1 on the REVLIM pin. When configured as a normally open switch the DMC60 will prevent the output from applying a negative voltage to the load when the limit switch closes, causing the DMC60 to detect a logic 0 on the REVLIM pin. This parameter is stored in nonvolatile memory and is preserved across power cycles.  <a href="#a14b4df6835e63f2839aa7b9a0b97324b">More...</a><br /></td></tr>
<tr class="separator:a14b4df6835e63f2839aa7b9a0b97324b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cfae410c8f0831ce0fb573965b7c12"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a38cfae410c8f0831ce0fb573965b7c12">getSoftRevThreshold</a> (bool *enable, int *limit, int tmsWait)</td></tr>
<tr class="memdesc:a38cfae410c8f0831ce0fb573965b7c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current soft reverse threshold value.  <a href="#a38cfae410c8f0831ce0fb573965b7c12">More...</a><br /></td></tr>
<tr class="separator:a38cfae410c8f0831ce0fb573965b7c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcb3e97d51333936d557bff99cae6f4"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a8bcb3e97d51333936d557bff99cae6f4">configAnalogStatusFramePeriod</a> (uint32_t periodMs, int tmsWait)</td></tr>
<tr class="memdesc:a8bcb3e97d51333936d557bff99cae6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the rate at which the DMC60 transmits Analog Input, Current, Temperature, and Battery Voltage Status Frames. These status frames are formatted as STSANALOG packets and are described in the Periodic Status Messages section. The frame rate can be set to any value between 1 millisecond and 30000 milliseconds. Power cycling the DMC60 will result in the device reverting to the default frame rate, which is 100 milliseconds.  <a href="#a8bcb3e97d51333936d557bff99cae6f4">More...</a><br /></td></tr>
<tr class="separator:a8bcb3e97d51333936d557bff99cae6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659311773a28f913a56ce14e9f662b15"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a659311773a28f913a56ce14e9f662b15">getAnalogStatusFramePeriod</a> (uint32_t *periodMs, int tmsWait)</td></tr>
<tr class="memdesc:a659311773a28f913a56ce14e9f662b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current analog status frame period.  <a href="#a659311773a28f913a56ce14e9f662b15">More...</a><br /></td></tr>
<tr class="separator:a659311773a28f913a56ce14e9f662b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e935d2b29ff546602d1b84e6f8f97b8"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a1e935d2b29ff546602d1b84e6f8f97b8">configEncoderStatusFramePeriod</a> (uint32_t periodMs, int tmsWait)</td></tr>
<tr class="memdesc:a1e935d2b29ff546602d1b84e6f8f97b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the rate at which the DMC60 transmits Quadrature Encoder Status Frames. These status frames are formatted as STSENCODER packets and are described in the Periodic Status Messages section. The frame rate can be set to any value between 1 millisecond and 30000 milliseconds. Power cycling the DMC60 will result in the device reverting to the default frame rate, which is 100 milliseconds.  <a href="#a1e935d2b29ff546602d1b84e6f8f97b8">More...</a><br /></td></tr>
<tr class="separator:a1e935d2b29ff546602d1b84e6f8f97b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb92935ec7d2a4f6b66de7230a66e2f"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#aefb92935ec7d2a4f6b66de7230a66e2f">getEncoderStatusFramePeriod</a> (uint32_t *periodMs, int tmsWait)</td></tr>
<tr class="memdesc:aefb92935ec7d2a4f6b66de7230a66e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current encoder status frame period.  <a href="#aefb92935ec7d2a4f6b66de7230a66e2f">More...</a><br /></td></tr>
<tr class="separator:aefb92935ec7d2a4f6b66de7230a66e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36016b56320decf83bea78a4aa183e2"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ac36016b56320decf83bea78a4aa183e2">configGeneralStatusFramePeriod</a> (uint32_t periodMs, int tmsWait)</td></tr>
<tr class="memdesc:ac36016b56320decf83bea78a4aa183e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the rate at which the DMC60 transmits General Status Frames. These status frames are formatted as STSGENERAL packets and are described in the Periodic Status Messages section. The frame rate can be set to any value between 1 millisecond and 30000 milliseconds. Power cycling the DMC60 will result in the device reverting to the default frame rate, which is 10 milliseconds.  <a href="#ac36016b56320decf83bea78a4aa183e2">More...</a><br /></td></tr>
<tr class="separator:ac36016b56320decf83bea78a4aa183e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692c4796494a84f5555cc1b57c6a9c42"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a692c4796494a84f5555cc1b57c6a9c42">getGeneralStatusFramePeriod</a> (uint32_t *periodMs, int tmsWait)</td></tr>
<tr class="memdesc:a692c4796494a84f5555cc1b57c6a9c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current general status frame period.  <a href="#a692c4796494a84f5555cc1b57c6a9c42">More...</a><br /></td></tr>
<tr class="separator:a692c4796494a84f5555cc1b57c6a9c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c9af872e64be9c5049580001bdc8a9"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a90c9af872e64be9c5049580001bdc8a9">setEncoderPosition</a> (int position, int tmsWait)</td></tr>
<tr class="memdesc:a90c9af872e64be9c5049580001bdc8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the encoder position. The encoder position is maintained by the QEI module of the DMC60s MCU and is continuously updated by the pulse train applied to QEA and QEB inputs of the expansion header. At power on the encoders position is initialized to zero. This may not correspond with the zero point thats defined in the end user application, and as such, it may be necessary to set the encoder to a specific position or reset it to 0 after performing a homing sequence. The encoders position is used for closed loop position control and for determining whether the forward soft limit or reverse soft limit have been hit. The encoder position should only be configured while the DMC60s output is disabled.  <a href="#a90c9af872e64be9c5049580001bdc8a9">More...</a><br /></td></tr>
<tr class="separator:a90c9af872e64be9c5049580001bdc8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdd853858f2b702a3b6b148e2f5c969"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a5fdd853858f2b702a3b6b148e2f5c969">getEncoderPosition</a> (int *position, int tmsWait)</td></tr>
<tr class="memdesc:a5fdd853858f2b702a3b6b148e2f5c969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the encoder position. The encoder position is maintained by the QEI module of the DMC60s MCU and is continuously updated by the pulse train applied to QEA and QEB inputs of the expansion header. At power on the encoders position is initialized to zero. This may not correspond with the zero point thats defined in the end user application, and as such, it may be necessary to set the encoder to a specific position or reset it to 0 after performing a homing sequence. The encoders position is used for closed loop position control and for determining whether the forward soft limit or reverse soft limit have been hit. The encoder position should only be configured while the DMC60s output is disabled.  <a href="#a5fdd853858f2b702a3b6b148e2f5c969">More...</a><br /></td></tr>
<tr class="separator:a5fdd853858f2b702a3b6b148e2f5c969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a8f0a5a64b9dfab92441da2af4bcc4"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a13a8f0a5a64b9dfab92441da2af4bcc4">setClearPositionOnIndex</a> (bool enable, int tmsWait)</td></tr>
<tr class="memdesc:a13a8f0a5a64b9dfab92441da2af4bcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the index pin will cause the position count to reset.  <a href="#a13a8f0a5a64b9dfab92441da2af4bcc4">More...</a><br /></td></tr>
<tr class="separator:a13a8f0a5a64b9dfab92441da2af4bcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fedb67253fcf6ce76b890b04177064b"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a2fedb67253fcf6ce76b890b04177064b">getClearPositionOnIndex</a> (bool *enable, int tmsWait)</td></tr>
<tr class="memdesc:a2fedb67253fcf6ce76b890b04177064b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not the index pin will cause the position count to reset.  <a href="#a2fedb67253fcf6ce76b890b04177064b">More...</a><br /></td></tr>
<tr class="separator:a2fedb67253fcf6ce76b890b04177064b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb65e5fe38e93f88e54a1ff88c2e3be"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a3bb65e5fe38e93f88e54a1ff88c2e3be">setClearPositionOnFwdLimit</a> (bool enable, int tmsWait)</td></tr>
<tr class="memdesc:a3bb65e5fe38e93f88e54a1ff88c2e3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the forward limit switch pin will cause the position count to reset.  <a href="#a3bb65e5fe38e93f88e54a1ff88c2e3be">More...</a><br /></td></tr>
<tr class="separator:a3bb65e5fe38e93f88e54a1ff88c2e3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1f241c12e126b49bd228f0bd3944d1"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a1f1f241c12e126b49bd228f0bd3944d1">getClearPositionOnFwdLimit</a> (bool *enable, int tmsWait)</td></tr>
<tr class="memdesc:a1f1f241c12e126b49bd228f0bd3944d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not the fwd limit switch pin will cause the position count to reset.  <a href="#a1f1f241c12e126b49bd228f0bd3944d1">More...</a><br /></td></tr>
<tr class="separator:a1f1f241c12e126b49bd228f0bd3944d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b71a242b0be616396d9ade17364096d"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a6b71a242b0be616396d9ade17364096d">setClearPositionOnRevLimit</a> (bool enable, int tmsWait)</td></tr>
<tr class="memdesc:a6b71a242b0be616396d9ade17364096d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the reverse limit switch pin will cause the position count to reset.  <a href="#a6b71a242b0be616396d9ade17364096d">More...</a><br /></td></tr>
<tr class="separator:a6b71a242b0be616396d9ade17364096d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2481131750ba67b4bf1ca293426606"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#afb2481131750ba67b4bf1ca293426606">getClearPositionOnRevLimit</a> (bool *enable, int tmsWait)</td></tr>
<tr class="memdesc:afb2481131750ba67b4bf1ca293426606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not the reverse limit switch pin will cause the position count to reset.  <a href="#afb2481131750ba67b4bf1ca293426606">More...</a><br /></td></tr>
<tr class="separator:afb2481131750ba67b4bf1ca293426606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3036f6d918200a53b435ec965ac1384f"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a3036f6d918200a53b435ec965ac1384f">setIndexActiveEdge</a> (bool edge, int tmsWait)</td></tr>
<tr class="memdesc:a3036f6d918200a53b435ec965ac1384f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the active edge of the index pin.  <a href="#a3036f6d918200a53b435ec965ac1384f">More...</a><br /></td></tr>
<tr class="separator:a3036f6d918200a53b435ec965ac1384f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052f47cd6fafa996eb5f443ea130abab"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a052f47cd6fafa996eb5f443ea130abab">getIndexActiveEdge</a> (bool *edge, int tmsWait)</td></tr>
<tr class="memdesc:a052f47cd6fafa996eb5f443ea130abab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the active edge of the index pin.  <a href="#a052f47cd6fafa996eb5f443ea130abab">More...</a><br /></td></tr>
<tr class="separator:a052f47cd6fafa996eb5f443ea130abab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23c199980033facc445efc876aab41a"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ab23c199980033facc445efc876aab41a">resetStickyFaults</a> (int tmsWait)</td></tr>
<tr class="memdesc:ab23c199980033facc445efc876aab41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the counts stored in the sticky faults.  <a href="#ab23c199980033facc445efc876aab41a">More...</a><br /></td></tr>
<tr class="separator:ab23c199980033facc445efc876aab41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6068613835ef3a23b43f618bfdc7abed"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a6068613835ef3a23b43f618bfdc7abed">resetOverTempStickyFaults</a> (int tmsWait)</td></tr>
<tr class="memdesc:a6068613835ef3a23b43f618bfdc7abed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the overtemp sticky fault count.  <a href="#a6068613835ef3a23b43f618bfdc7abed">More...</a><br /></td></tr>
<tr class="separator:a6068613835ef3a23b43f618bfdc7abed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc39a79eec7762e7c20686ce1598863"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#aedc39a79eec7762e7c20686ce1598863">resetOverCurrentStickyFaults</a> (int tmsWait)</td></tr>
<tr class="memdesc:aedc39a79eec7762e7c20686ce1598863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the overcurrent sticky fault count.  <a href="#aedc39a79eec7762e7c20686ce1598863">More...</a><br /></td></tr>
<tr class="separator:aedc39a79eec7762e7c20686ce1598863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6193038b50da23806cb5afa54a4377bb"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a6193038b50da23806cb5afa54a4377bb">resetUnderVoltageStickyFaults</a> (int tmsWait)</td></tr>
<tr class="memdesc:a6193038b50da23806cb5afa54a4377bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the undervoltage sticky fault count.  <a href="#a6193038b50da23806cb5afa54a4377bb">More...</a><br /></td></tr>
<tr class="separator:a6193038b50da23806cb5afa54a4377bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9b502f306e9dcb02b227354a602fd1"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#afe9b502f306e9dcb02b227354a602fd1">resetGateDriverStickyFaults</a> (int tmsWait)</td></tr>
<tr class="memdesc:afe9b502f306e9dcb02b227354a602fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the gate driver sticky fault count.  <a href="#afe9b502f306e9dcb02b227354a602fd1">More...</a><br /></td></tr>
<tr class="separator:afe9b502f306e9dcb02b227354a602fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25446adf38e99edaf8ffb1bddf000b9"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ae25446adf38e99edaf8ffb1bddf000b9">resetCommStickyFaults</a> (int tmsWait)</td></tr>
<tr class="memdesc:ae25446adf38e99edaf8ffb1bddf000b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the comm sticky fault count.  <a href="#ae25446adf38e99edaf8ffb1bddf000b9">More...</a><br /></td></tr>
<tr class="separator:ae25446adf38e99edaf8ffb1bddf000b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06083d8ee1fb496e33771aa088a1790"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ac06083d8ee1fb496e33771aa088a1790">getActiveFaults</a> (uint32_t *value, int tmsWait)</td></tr>
<tr class="memdesc:ac06083d8ee1fb496e33771aa088a1790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the active fault bit field from the motor controller.  <a href="#ac06083d8ee1fb496e33771aa088a1790">More...</a><br /></td></tr>
<tr class="separator:ac06083d8ee1fb496e33771aa088a1790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c86504442287cb0a9b1b82dd6bd5af"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a83c86504442287cb0a9b1b82dd6bd5af">getStickyFaults</a> (uint32_t *value, int tmsWait)</td></tr>
<tr class="memdesc:a83c86504442287cb0a9b1b82dd6bd5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the sticky fault bit field from the motor controller.  <a href="#a83c86504442287cb0a9b1b82dd6bd5af">More...</a><br /></td></tr>
<tr class="separator:a83c86504442287cb0a9b1b82dd6bd5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82ad817300e14bc64a009c60723489c"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ab82ad817300e14bc64a009c60723489c">getOverTempStickyFaultCount</a> (uint32_t *value, int tmsWait)</td></tr>
<tr class="memdesc:ab82ad817300e14bc64a009c60723489c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of over temp sticky faults.  <a href="#ab82ad817300e14bc64a009c60723489c">More...</a><br /></td></tr>
<tr class="separator:ab82ad817300e14bc64a009c60723489c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad959714e50976d38b7e99158bddc35ef"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ad959714e50976d38b7e99158bddc35ef">getOverCurrentStickyFaultCount</a> (uint32_t *value, int tmsWait)</td></tr>
<tr class="memdesc:ad959714e50976d38b7e99158bddc35ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of over current sticky faults.  <a href="#ad959714e50976d38b7e99158bddc35ef">More...</a><br /></td></tr>
<tr class="separator:ad959714e50976d38b7e99158bddc35ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7345700ee674050b236f0b979068a4a"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ad7345700ee674050b236f0b979068a4a">getUnderVoltageStickyFaultCount</a> (uint32_t *value, int tmsWait)</td></tr>
<tr class="memdesc:ad7345700ee674050b236f0b979068a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of under voltage sticky faults.  <a href="#ad7345700ee674050b236f0b979068a4a">More...</a><br /></td></tr>
<tr class="separator:ad7345700ee674050b236f0b979068a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934ac1fa07a46eb0e5fdaa347d2b8f24"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a934ac1fa07a46eb0e5fdaa347d2b8f24">getGateDriverStickyFaultCount</a> (uint32_t *value, int tmsWait)</td></tr>
<tr class="memdesc:a934ac1fa07a46eb0e5fdaa347d2b8f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of gate driver sticky faults.  <a href="#a934ac1fa07a46eb0e5fdaa347d2b8f24">More...</a><br /></td></tr>
<tr class="separator:a934ac1fa07a46eb0e5fdaa347d2b8f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91c8552ff86e600e24796fe9ffa23b5"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ab91c8552ff86e600e24796fe9ffa23b5">getCommStickyFaultCount</a> (uint32_t *value, int tmsWait)</td></tr>
<tr class="memdesc:ab91c8552ff86e600e24796fe9ffa23b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of comm sticky faults.  <a href="#ab91c8552ff86e600e24796fe9ffa23b5">More...</a><br /></td></tr>
<tr class="separator:ab91c8552ff86e600e24796fe9ffa23b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b37d792f50128266d554b676647dac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a81b37d792f50128266d554b676647dac">setOverrideBC</a> (bool enable, bool brakecoast)</td></tr>
<tr class="memdesc:a81b37d792f50128266d554b676647dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the brake/coast mode override.  <a href="#a81b37d792f50128266d554b676647dac">More...</a><br /></td></tr>
<tr class="separator:a81b37d792f50128266d554b676647dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51af9c56d6adc211c8e7626b70f486ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a51af9c56d6adc211c8e7626b70f486ce">setReverse</a> (bool reverse)</td></tr>
<tr class="memdesc:a51af9c56d6adc211c8e7626b70f486ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reverse bit in control0 frame. This causes the motor controller to reverse drive of the motor.  <a href="#a51af9c56d6adc211c8e7626b70f486ce">More...</a><br /></td></tr>
<tr class="separator:a51af9c56d6adc211c8e7626b70f486ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116ed15cc29bfa08b30650b71ca33c34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a116ed15cc29bfa08b30650b71ca33c34">setLimitSwitchOverride</a> (bool enable, bool forwardSwitchEnable, bool reverseSwitchEnable)</td></tr>
<tr class="memdesc:a116ed15cc29bfa08b30650b71ca33c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the override bits in the control frame. This overrides the limit switch parameters to allow enabling and disabling the limit switches realtime,.  <a href="#a116ed15cc29bfa08b30650b71ca33c34">More...</a><br /></td></tr>
<tr class="separator:a116ed15cc29bfa08b30650b71ca33c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90adc44cfd52bc13e9f122bd76292315"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a90adc44cfd52bc13e9f122bd76292315">setReverseFeedbackSensor</a> (bool reverse)</td></tr>
<tr class="memdesc:a90adc44cfd52bc13e9f122bd76292315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reverse bit in control0 frame. This causes the motor controller to reverse drive of the motor.  <a href="#a90adc44cfd52bc13e9f122bd76292315">More...</a><br /></td></tr>
<tr class="separator:a90adc44cfd52bc13e9f122bd76292315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e393a2aba7209f35655608dc8cc154"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a40e393a2aba7209f35655608dc8cc154">setRampRate</a> (unsigned short rampRate)</td></tr>
<tr class="memdesc:a40e393a2aba7209f35655608dc8cc154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the open loop ramp rate that is sent within each control0 frame.  <a href="#a40e393a2aba7209f35655608dc8cc154">More...</a><br /></td></tr>
<tr class="separator:a40e393a2aba7209f35655608dc8cc154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7c86f7e7a23dbb33a9bf62de933389"><td class="memItemLeft" align="right" valign="top"><a id="a7f7c86f7e7a23dbb33a9bf62de933389"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a7f7c86f7e7a23dbb33a9bf62de933389">sendControl</a> ()</td></tr>
<tr class="memdesc:a7f7c86f7e7a23dbb33a9bf62de933389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resends the control0 frame. If it has not been sent before, it will start sending the default _control0 frame at 100ms. <br /></td></tr>
<tr class="separator:a7f7c86f7e7a23dbb33a9bf62de933389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3139ed564a30ee256daa100c9e8fc45a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a3139ed564a30ee256daa100c9e8fc45a">sendControl</a> (ControlMode Mode, double trgt)</td></tr>
<tr class="memdesc:a3139ed564a30ee256daa100c9e8fc45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the control0 frame with the specified parameters at a specified period. This is the main control of the DMC60C. This frame must be sent every 104ms or the DMC60C will go into standby mode.  <a href="#a3139ed564a30ee256daa100c9e8fc45a">More...</a><br /></td></tr>
<tr class="separator:a3139ed564a30ee256daa100c9e8fc45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40de1cac1cf8f2011b1bd78131f5a9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ae40de1cac1cf8f2011b1bd78131f5a9d">sendControl</a> (ControlMode Mode, double trgt, uint16_t ramp, uint32_t periodMs)</td></tr>
<tr class="memdesc:ae40de1cac1cf8f2011b1bd78131f5a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the control0 frame with the specified parameters at a specified period. This is the main control of the DMC60C. This frame must be sent every 104ms or the DMC60C will go into standby mode.  <a href="#ae40de1cac1cf8f2011b1bd78131f5a9d">More...</a><br /></td></tr>
<tr class="separator:ae40de1cac1cf8f2011b1bd78131f5a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312dfdcde2079a12157e5d7c39b577a8"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a312dfdcde2079a12157e5d7c39b577a8">getAnalogStatus</a> (STSANALOG *stsAnalogOut)</td></tr>
<tr class="memdesc:a312dfdcde2079a12157e5d7c39b577a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the latest STSANALOG frame from the DMC60C.  <a href="#a312dfdcde2079a12157e5d7c39b577a8">More...</a><br /></td></tr>
<tr class="separator:a312dfdcde2079a12157e5d7c39b577a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81187bef46e108590fd02ed019c6adbe"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a81187bef46e108590fd02ed019c6adbe">getEncoderStatus</a> (STSENCODER *stsEncoderOut)</td></tr>
<tr class="memdesc:a81187bef46e108590fd02ed019c6adbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the latest STSENCODER frame from the DMC60C.  <a href="#a81187bef46e108590fd02ed019c6adbe">More...</a><br /></td></tr>
<tr class="separator:a81187bef46e108590fd02ed019c6adbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f050cdd3671f10149459d24449726a"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ae5f050cdd3671f10149459d24449726a">getGeneralStatus</a> (STSGENERAL *stsGeneralOut)</td></tr>
<tr class="memdesc:ae5f050cdd3671f10149459d24449726a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the latest STSGENERAL frame from the DMC60C.  <a href="#ae5f050cdd3671f10149459d24449726a">More...</a><br /></td></tr>
<tr class="separator:ae5f050cdd3671f10149459d24449726a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff33401f4a821c4628317cb9cf2e355d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#aff33401f4a821c4628317cb9cf2e355d">SetControlMode</a> (ControlMode Mode)</td></tr>
<tr class="memdesc:aff33401f4a821c4628317cb9cf2e355d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ControlMode in the control0 frame. The frame must be resent with <a class="el" href="class_d_m_c60_low_level.html#a7f7c86f7e7a23dbb33a9bf62de933389" title="Resends the control0 frame. If it has not been sent before, it will start sending the default _contro...">sendControl()</a> to have any effect, although this is not recommended in most cases.  <a href="#aff33401f4a821c4628317cb9cf2e355d">More...</a><br /></td></tr>
<tr class="separator:aff33401f4a821c4628317cb9cf2e355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7191ed017cb067d031edbfd05e406922"><td class="memItemLeft" align="right" valign="top">ControlMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a7191ed017cb067d031edbfd05e406922">GetControlMode</a> () const</td></tr>
<tr class="memdesc:a7191ed017cb067d031edbfd05e406922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current controlMode in the control0 frame.  <a href="#a7191ed017cb067d031edbfd05e406922">More...</a><br /></td></tr>
<tr class="separator:a7191ed017cb067d031edbfd05e406922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8588d024d1b45efb197f6a0345ae8d77"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a8588d024d1b45efb197f6a0345ae8d77">setContinuousCurrentLimit</a> (double currentAmps)</td></tr>
<tr class="memdesc:a8588d024d1b45efb197f6a0345ae8d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the continuous current limit. This applies only if current limiting is enabled. The continuous current limit is the maximum current that can be drawn by the DMC60C AFTER the peak current limit has been hit for the peak current duration. If the continuous current limit is greater than or equal to the peak current limit, then the DMC60C will begin limiting the current immediately after the continuous current limit is exceeded.  <a href="#a8588d024d1b45efb197f6a0345ae8d77">More...</a><br /></td></tr>
<tr class="separator:a8588d024d1b45efb197f6a0345ae8d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e6ccb82d52958b882a55e33ce0d94a"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#af0e6ccb82d52958b882a55e33ce0d94a">getContinuousCurrentLimit</a> (double *currentAmps)</td></tr>
<tr class="memdesc:af0e6ccb82d52958b882a55e33ce0d94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the continuous current limit.  <a href="#af0e6ccb82d52958b882a55e33ce0d94a">More...</a><br /></td></tr>
<tr class="separator:af0e6ccb82d52958b882a55e33ce0d94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4ba39501eceb139d71e28b5b7e51f2"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a4b4ba39501eceb139d71e28b5b7e51f2">setPeakCurrentLimit</a> (double currentAmps)</td></tr>
<tr class="memdesc:a4b4ba39501eceb139d71e28b5b7e51f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the peak current limit. This only applies if current limiting is enabled. The peak current is the max current that can be applied to the motor at any given time. This limit can be applied for up to [peak current duration] milliseconds. Afterwards the continuous current limit will be applied. If the peak current limit is set to a value lower than the continuous current limit, the DMC60C will apply the continuous current limit immediately after it detects that the continuous current limit has been exceeded.  <a href="#a4b4ba39501eceb139d71e28b5b7e51f2">More...</a><br /></td></tr>
<tr class="separator:a4b4ba39501eceb139d71e28b5b7e51f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad886c016dd702d04393512096c9a1abd"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ad886c016dd702d04393512096c9a1abd">getPeakCurrentLimit</a> (double *currentAmps)</td></tr>
<tr class="memdesc:ad886c016dd702d04393512096c9a1abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the peak current limit.  <a href="#ad886c016dd702d04393512096c9a1abd">More...</a><br /></td></tr>
<tr class="separator:ad886c016dd702d04393512096c9a1abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e00b7a7a2e812a21507222bced95cb"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a14e00b7a7a2e812a21507222bced95cb">setPeakCurrentDuration</a> (int durationMs)</td></tr>
<tr class="memdesc:a14e00b7a7a2e812a21507222bced95cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the peak current duration. This only applies if current limiting is enabled. The peak current duration is the maximum amount of time the peak current can be applied to the motor. After this duration, the continuous current limit will be applied. If the duration is set to 0, the DMC60C will begin applying the continuous current limit immediately after the peak current limit has been exceeded.  <a href="#a14e00b7a7a2e812a21507222bced95cb">More...</a><br /></td></tr>
<tr class="separator:a14e00b7a7a2e812a21507222bced95cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5eae9514bed579e3ea8fbb108f5de08"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#ae5eae9514bed579e3ea8fbb108f5de08">getPeakCurrentDuration</a> (int *durationMs)</td></tr>
<tr class="memdesc:ae5eae9514bed579e3ea8fbb108f5de08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the peak current duration.  <a href="#ae5eae9514bed579e3ea8fbb108f5de08">More...</a><br /></td></tr>
<tr class="separator:ae5eae9514bed579e3ea8fbb108f5de08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbf7d0c4df2d937090f01532bdfd3a0"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#aabbf7d0c4df2d937090f01532bdfd3a0">enableCurrentLimit</a> (bool enabled)</td></tr>
<tr class="memdesc:aabbf7d0c4df2d937090f01532bdfd3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables current limiting mode.  <a href="#aabbf7d0c4df2d937090f01532bdfd3a0">More...</a><br /></td></tr>
<tr class="separator:aabbf7d0c4df2d937090f01532bdfd3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a33380e62d240cc25fb1baa7eee34db"><td class="memItemLeft" align="right" valign="top"><a id="a3a33380e62d240cc25fb1baa7eee34db"></a>
DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><b>isCurrentLimitEnabled</b> (bool *enabled)</td></tr>
<tr class="separator:a3a33380e62d240cc25fb1baa7eee34db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada517c92b8bebb681ebfb51fe8aa76f1"><td class="memItemLeft" align="right" valign="top"><a id="ada517c92b8bebb681ebfb51fe8aa76f1"></a>
DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><b>setCurrentLimitPGain</b> (double P)</td></tr>
<tr class="separator:ada517c92b8bebb681ebfb51fe8aa76f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd9ece4ec6ee3cccd24e73bf4edc757"><td class="memItemLeft" align="right" valign="top"><a id="a5dd9ece4ec6ee3cccd24e73bf4edc757"></a>
DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentLimitPGain</b> (double *P)</td></tr>
<tr class="separator:a5dd9ece4ec6ee3cccd24e73bf4edc757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aee7d72b1bb2e2109c42fe92ee1570c"><td class="memItemLeft" align="right" valign="top"><a id="a6aee7d72b1bb2e2109c42fe92ee1570c"></a>
DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><b>setCurrentLimitIGain</b> (double I)</td></tr>
<tr class="separator:a6aee7d72b1bb2e2109c42fe92ee1570c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1922a433923660c730f70b8caf0d8d48"><td class="memItemLeft" align="right" valign="top"><a id="a1922a433923660c730f70b8caf0d8d48"></a>
DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentLimitIGain</b> (double *I)</td></tr>
<tr class="separator:a1922a433923660c730f70b8caf0d8d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3886c31f49b7f5849f667970240bdf"><td class="memItemLeft" align="right" valign="top"><a id="abe3886c31f49b7f5849f667970240bdf"></a>
DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><b>setCurrentLimitDGain</b> (double D)</td></tr>
<tr class="separator:abe3886c31f49b7f5849f667970240bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca1f46c1a749768e0c4d5346236d087"><td class="memItemLeft" align="right" valign="top"><a id="a9ca1f46c1a749768e0c4d5346236d087"></a>
DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentLimitDGain</b> (double *D)</td></tr>
<tr class="separator:a9ca1f46c1a749768e0c4d5346236d087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99336f2ea1e619787f85b2e57da05298"><td class="memItemLeft" align="right" valign="top"><a id="a99336f2ea1e619787f85b2e57da05298"></a>
DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><b>setCurrentLimitFGain</b> (double F)</td></tr>
<tr class="separator:a99336f2ea1e619787f85b2e57da05298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2bcf6b9040c95d4f48a992be614442"><td class="memItemLeft" align="right" valign="top"><a id="adb2bcf6b9040c95d4f48a992be614442"></a>
DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentLimitFGain</b> (double *F)</td></tr>
<tr class="separator:adb2bcf6b9040c95d4f48a992be614442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0c963702e6295a005adde4dfc10668"><td class="memItemLeft" align="right" valign="top"><a id="aee0c963702e6295a005adde4dfc10668"></a>
DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><b>setCurrentLimitIZone</b> (double I)</td></tr>
<tr class="separator:aee0c963702e6295a005adde4dfc10668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd197aebe1768cbf910cd15cecebf34"><td class="memItemLeft" align="right" valign="top"><a id="a7dd197aebe1768cbf910cd15cecebf34"></a>
DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentLimitIZone</b> (double *I)</td></tr>
<tr class="separator:a7dd197aebe1768cbf910cd15cecebf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dbcc1679007594265f6b7a005344e6"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a43dbcc1679007594265f6b7a005344e6">setADCMultiplier</a> (float value, int tmsWait)</td></tr>
<tr class="memdesc:a43dbcc1679007594265f6b7a005344e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the constant used by the DMC60 to convert ADC measurements into an associated load current in amps. The DMC60 uses a combination of a current sense resistor, bidirectional current sense amplifier with a 50V/V gain, and a 3.3V reference to measure load currents. The current sense amplifier is biased at 1.65V, which means a load current of 0 amps will result in the current sense amplifier outputting 1.65V. At power on the DMC60 performs a calibration procedure to determine the ADC sample value (smpZeroCurrent) corresponding to no current flow between the M+ and M- terminals. When current flows from the M+ terminal to the M- terminal the current sense amplifier outputs a voltage between 1.65V and 3.3V, which corresponds to positive current flow. When current flows from the M- terminal to the M+ terminal the current sense amplifier outputs a voltage between 1.65V and 0V, corresponding to negative current flow. The DMC60 uses an internal 12-bit ADC to convert this voltage into digitized value every 500 microseconds. The digitized value is then converted into a signed 16.6 fixed point current measurement (in Amps) using the following formula: crntLoad=(smpAdc-smpZeroCurrent)×mplrAdcCurrent. The multiplier (mplrAdcCurrent) that corresponds to a given sense resistance (resCrntSns, in ohms) can be calculated using the following formula: mplrAdcCurrent=(vref/4096×1/(resCrntSns×50))×65536. For example, if the sense resistor has a nominal value of 500 µohms then the mplrAdcCurrent=(3.3/4096×1/(0.0005×50))×65536=2112 or 0x00000840 in hexadecimal. The DMC60 comes pre-programmed with a multiplier that corresponds to the expected sense resistance (approximately 510 µohms) so it should not be necessary to configure the multiplier. However, if current measurements appear to be off then paramAdcCurrentMultiplier can be used to adjust the multiplier used. This parameter is stored in nonvolatile memory and is preserved across power cycles.  <a href="#a43dbcc1679007594265f6b7a005344e6">More...</a><br /></td></tr>
<tr class="separator:a43dbcc1679007594265f6b7a005344e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed36e81f958ed8189f444f2f198b4b2f"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#aed36e81f958ed8189f444f2f198b4b2f">getADCMultiplier</a> (float *value, int tmsWait)</td></tr>
<tr class="memdesc:aed36e81f958ed8189f444f2f198b4b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the currently stored value for.  <a href="#aed36e81f958ed8189f444f2f198b4b2f">More...</a><br /></td></tr>
<tr class="separator:aed36e81f958ed8189f444f2f198b4b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4284f8a0e841a13a23bdda94c58bad40"><td class="memItemLeft" align="right" valign="top">DMC_Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_m_c60_low_level.html#a4284f8a0e841a13a23bdda94c58bad40">enterBootloader</a> ()</td></tr>
<tr class="memdesc:a4284f8a0e841a13a23bdda94c58bad40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the DMC60C into bootloader mode.  <a href="#a4284f8a0e841a13a23bdda94c58bad40">More...</a><br /></td></tr>
<tr class="separator:a4284f8a0e841a13a23bdda94c58bad40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Low Level DMC60C Interface. </p>
<p>This class contains all of the low level functions used to communicate with the DMC60C. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a293daec4f3d41bb4d7a414cdf0cea151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293daec4f3d41bb4d7a414cdf0cea151">&#9670;&nbsp;</a></span>DMC60LowLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC60LowLevel::DMC60LowLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">constructortype&#160;</td>
          <td class="paramname"><em>type</em> = <code>constructortype::useDeviceNumber</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="class_d_m_c60_low_level.html" title="Low Level DMC60C Interface. ">DMC60LowLevel</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The deviceNumber of the DMC60C Motor. If type == useSessionID, this is the session ID of the device </td></tr>
    <tr><td class="paramname">verbose</td><td>A flag to enable verbose feedback. </td></tr>
    <tr><td class="paramname">type</td><td>If useDeviceNumber, value represents the deviceNumber of the DMC60C to connect to. If useSessionID, value represents the session ID of the DMC60C to connect to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac70dea7eadd417e116b458a186736d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70dea7eadd417e116b458a186736d31">&#9670;&nbsp;</a></span>setDeviceNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::setDeviceNumber </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>newdevnum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the deviceNumber of the DMC60C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newdevnum</td><td>The desired device number (0-64). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DMC_Code Status code. </dd></dl>

</div>
</div>
<a id="a94a517b93f859045fa310fa0725a248d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a517b93f859045fa310fa0725a248d">&#9670;&nbsp;</a></span>getDeviceNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t DMC60LowLevel::getDeviceNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the deviceNumber of the DMC60C. </p>
<dl class="section return"><dt>Returns</dt><dd>Device number of DMC60C. </dd></dl>

</div>
</div>
<a id="ad9df5e94868d569b7ed95380856494fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9df5e94868d569b7ed95380856494fa">&#9670;&nbsp;</a></span>setDeviceName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::setDeviceName </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szDevName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>cbName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the deviceName of the DMC60C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szDevName</td><td>Character pointer to desired name. </td></tr>
    <tr><td class="paramname">cbName</td><td>Byte count of name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a28f5e1a5c2bed34444dfb53ed8a33b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f5e1a5c2bed34444dfb53ed8a33b97">&#9670;&nbsp;</a></span>getDeviceName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMC60LowLevel::getDeviceName </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szNameBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the device name of the DMC60C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szNameBuf</td><td>Buffer to store the name in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af64f9fea8911a687f4b913bd83ea17cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64f9fea8911a687f4b913bd83ea17cc">&#9670;&nbsp;</a></span>getFWVerBoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t DMC60LowLevel::getFWVerBoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the bootloader firmware of the DMC60C. </p>
<dl class="section return"><dt>Returns</dt><dd>Firmware version of bootloader. </dd></dl>

</div>
</div>
<a id="ab3ed7be48080a173974740add6095061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ed7be48080a173974740add6095061">&#9670;&nbsp;</a></span>getFWVerApp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t DMC60LowLevel::getFWVerApp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the application firmware of the DMC60C. </p>
<dl class="section return"><dt>Returns</dt><dd>Firmware version of application. </dd></dl>

</div>
</div>
<a id="a98c251a75c7acfabbaace31f171f7c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c251a75c7acfabbaace31f171f7c63">&#9670;&nbsp;</a></span>getImgType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t DMC60LowLevel::getImgType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the currently running image type (bootloader, application, or aux bootloader). </p>
<dl class="section return"><dt>Returns</dt><dd>0 = App, 1 = Bootloader, 2 = Aux Bootloader. </dd></dl>

</div>
</div>
<a id="a7dbfbaaeda4f2bb9aa6efc0809ca4604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dbfbaaeda4f2bb9aa6efc0809ca4604">&#9670;&nbsp;</a></span>getSessId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t DMC60LowLevel::getSessId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the session ID assigned to the DMC60C. </p>
<dl class="section return"><dt>Returns</dt><dd>Session ID. </dd></dl>

</div>
</div>
<a id="a92177b3bace9694d2f43cbd0fdb095fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92177b3bace9694d2f43cbd0fdb095fc">&#9670;&nbsp;</a></span>fetchFWVer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::fetchFWVer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the device's firmware version information. This includes application firmware revision, bootloader firmware revision, and the time of firmware image that is currently running. This information is stored in the private member DMCInfo, and can be read with the get commands. </p>
<dl class="section return"><dt>Returns</dt><dd>Firmware version of application. </dd></dl>

</div>
</div>
<a id="adb575b74dda8721e3f539078f22a453d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb575b74dda8721e3f539078f22a453d">&#9670;&nbsp;</a></span>softReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::softReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the session ID assigned to the DMC60C. </p>
<dl class="section return"><dt>Returns</dt><dd>Status Code. </dd></dl>

</div>
</div>
<a id="a58b22c50f3cff5c769b2122867f7f8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b22c50f3cff5c769b2122867f7f8dc">&#9670;&nbsp;</a></span>flashLEDs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::flashLEDs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flashes the LEDs on the DMC60C in a rainbow pattern for 5 seconds. </p>
<dl class="section return"><dt>Returns</dt><dd>Status Code. </dd></dl>

</div>
</div>
<a id="a14c71fe83b27877d5583fe5a8be28f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c71fe83b27877d5583fe5a8be28f60">&#9670;&nbsp;</a></span>configPID_RampRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configPID_RampRate </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the closed loop ramp rate used by the specified closed loop profile slot. The closed loop ramp rate specifies the maximum number of throttle units the output can change by each time the control loop executes in closed loop control mode (Velocity, Position, or Current). For example, If the closed loop ramp rate is set to 1000 and the PID update function determines that the throttle should be increased by 5000 units then the immediate throttle increase will be limited to 1000 units. If the next PID Update doesnt change the target throttle output value, the throttle will be increased by another 1000 units the next time the control loop executes. This process will continue until the target throttle is reached or a new throttle value is calculated. The control loop executes once every 500 µs. Therefore, specifying a closed loop ramp rate of 16 would result in it taking approximately 1.02 seconds to go from 0% throttle (0) to 100% throttle (32767). Specifying a value of 0 for the closed loop ramp rate disables throttling and allows the output to be immediately set to the target value. This parameter is stored in nonvolatile memory and is preserved across power cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to configure. </td></tr>
    <tr><td class="paramname">ramp</td><td>Desired ramp rate. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a3d434505ed25e5033515d29b8c384963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d434505ed25e5033515d29b8c384963">&#9670;&nbsp;</a></span>getPID_RampRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getPID_RampRate </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ramp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the ramp rate value stored in the specified PID slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to configure. </td></tr>
    <tr><td class="paramname">ramp</td><td>Buffer to store ramp rate. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a37d3201e352d9936ee1b17c8b619724a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d3201e352d9936ee1b17c8b619724a">&#9670;&nbsp;</a></span>configPID_FwdMaxDuty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configPID_FwdMaxDuty </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the closed loop control maximum forward duty cycle used by the specified motor control profile slot. The maximum forward duty cycle is the largest positive duty cycle that may be applied to the output when motor control profile slot 0 is specified in a control frame that specifies one of the closed loop control modes (Velocity, Position, or Current). The value specified for this parameter should be restricted to be within the range of 0 to 32767. This parameter is stored in nonvolatile memory and is preserved across power cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to configure. </td></tr>
    <tr><td class="paramname">value</td><td>Max forward duty cycle (0-32767). </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a8c96ecf46de14b27dd66b271bd5b810b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c96ecf46de14b27dd66b271bd5b810b">&#9670;&nbsp;</a></span>getPID_FwdMaxDuty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getPID_FwdMaxDuty </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the forward max duty cycle stored in the specified PID slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to read from. </td></tr>
    <tr><td class="paramname">value</td><td>Buffer to store the ramp rate value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a99e317aaffe4fd7a78a0cb7f0719e7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e317aaffe4fd7a78a0cb7f0719e7ff">&#9670;&nbsp;</a></span>configPID_RevMaxDuty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configPID_RevMaxDuty </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the closed loop control maximum reverse duty cycle used by the specified motor control profile slot. The maximum reverse duty cycle is the largest negative duty cycle that may be applied to the output when motor control profile slot 0 is specified in a control frame that specifies one of the closed loop control modes (Velocity, Position, or Current). The value specified for this parameter should be restricted to be within the range of -32768 to 0. This parameter is stored in nonvolatile memory and is preserved across power cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to configure. </td></tr>
    <tr><td class="paramname">value</td><td>Max reverse duty cycle (-32768 to 0). </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a7a166312c6f384aa583dc64e2906d82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a166312c6f384aa583dc64e2906d82d">&#9670;&nbsp;</a></span>getPID_RevMaxDuty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getPID_RevMaxDuty </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the reverse max duty cycle stored in the specified PID slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to read from. </td></tr>
    <tr><td class="paramname">value</td><td>Buffer to store the ramp rate value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a71427a94539baeb0bf6216b7e77273d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71427a94539baeb0bf6216b7e77273d0">&#9670;&nbsp;</a></span>configPID_FwdNominal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configPID_FwdNominal </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the closed loop control nominal forward duty cycle used by the specified motor control profile slot. The nominal forward duty cycle is the smallest positive duty cycle that may be applied to the output when the closed loop error exceeds the allowable closed loop error specified for the selected motor profile slot. The closed loop nominal forward duty cycle is only utilized when the control frame specifies one of the closed loop control modes (Velocity, Position, or Current). The value specified for this parameter should be restricted to be within the range of 0 to 32767. This parameter is stored in nonvolatile memory and is preserved across power cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to configure. </td></tr>
    <tr><td class="paramname">value</td><td>Closed loop nominal duty cycle (0 to 32767). </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a5e5af58cb93535d0ec94de50832135b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5af58cb93535d0ec94de50832135b2">&#9670;&nbsp;</a></span>getPID_FwdNominal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getPID_FwdNominal </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the forward nominal duty cycle stored in the specified PID slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to read from. </td></tr>
    <tr><td class="paramname">value</td><td>Buffer to store the forward nominal duty cycle value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a5a56b1b380ab25e011139a45ed55969d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a56b1b380ab25e011139a45ed55969d">&#9670;&nbsp;</a></span>configPID_RevNominal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configPID_RevNominal </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the closed loop control nominal reverse duty cycle used by the specified motor control profile slot. The nominal reverse duty cycle is the smallest negative duty cycle that may be applied to the output when the closed loop error exceeds the allowable closed loop error specified for the selected motor profile slot. The closed loop nominal reverse duty cycle is only utilized when the control frame specifies one of the closed loop control modes (Velocity, Position, or Current). The value specified for this parameter should be restricted to be within the range of -32768 to 0. This parameter is stored in nonvolatile memory and is preserved across power cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to configure. </td></tr>
    <tr><td class="paramname">value</td><td>Closed loop nominal duty cycle (-32768 to 0). </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a5d8eba6c81857a24814b8d14be04f7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8eba6c81857a24814b8d14be04f7f2">&#9670;&nbsp;</a></span>getPID_RevNominal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getPID_RevNominal </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the reverse nominal duty cycle stored in the specified PID slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to read from. </td></tr>
    <tr><td class="paramname">value</td><td>Buffer to store the reverse nominal duty cycle value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="aee68dbd074890f405226b7eb5679bdc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee68dbd074890f405226b7eb5679bdc6">&#9670;&nbsp;</a></span>configPID_kP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configPID_kP </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the proportional gain constant used by the specified motor control profile slot. This constant is used during closed loop control to calculate a proportional increase or decrease in the throttle (duty cycle) due to the measured closed loop error. This parameter will be utilized for PID calculations when motor control profile slot 1 is specified in a control frame that specifies one of the closed loop control modes (Velocity, Position, or Current). This parameter is stored in nonvolatile memory and is preserved across power cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to configure. </td></tr>
    <tr><td class="paramname">value</td><td>P gain value to assign. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a594f412f085f2984f54aa31c58b394e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594f412f085f2984f54aa31c58b394e8">&#9670;&nbsp;</a></span>get_kP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::get_kP </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the P gain value of the specified slot and stores the value into a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to read. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to store value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a03819dfdc988e0cc03eca7b82b864203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03819dfdc988e0cc03eca7b82b864203">&#9670;&nbsp;</a></span>configPID_kI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configPID_kI </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the integral gain constant used by the specified motor control profile slot. This constant is used during closed loop control to calculate an integral increase or decrease in the throttle (duty cycle) due to the measured closed loop error. This parameter will be utilized for PID calculations when motor control profile slot 1 is specified in a control frame that specifies one of the closed loop control modes (Velocity, Position, or Current). This parameter is stored in nonvolatile memory and is preserved across power cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to configure. </td></tr>
    <tr><td class="paramname">value</td><td>I gain value to assign. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="aa6747dd7282f8eb0fcc0bb2f5f7112e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6747dd7282f8eb0fcc0bb2f5f7112e8">&#9670;&nbsp;</a></span>get_kI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::get_kI </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the I gain value of the specified slot and stores the value into a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to read. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to store value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a5017be8857d50f382506832785d0628c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5017be8857d50f382506832785d0628c">&#9670;&nbsp;</a></span>configPID_kD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configPID_kD </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the derivative gain constant used by the specified motor control profile slot. This constant is used during closed loop control to calculate the derivative increase or decrease in the throttle (duty cycle) due to the measured closed loop error. This parameter will be utilized for PID calculations when motor control profile slot 1 is specified in a control frame that specifies one of the closed loop control modes (Velocity, Position, or Current). This parameter is stored in nonvolatile memory and is preserved across power cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to configure. </td></tr>
    <tr><td class="paramname">value</td><td>D gain value to assign. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a9c37ab2b5cf7db4137b31d9d3848713d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c37ab2b5cf7db4137b31d9d3848713d">&#9670;&nbsp;</a></span>get_kD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::get_kD </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the D gain value of the specified slot and stores the value into a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to read. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to store value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="acb93f89537ea0661a0eca9aea52674c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb93f89537ea0661a0eca9aea52674c8">&#9670;&nbsp;</a></span>configPID_kF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configPID_kF </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the feed-forward gain constant used by the specified motor control profile slot. This constant is used during closed loop control to calculate the number of throttle units to contribute to the duty cycle as the proportion of the setpoint (target Velocity, Position, or Current) independent of the error. For example, if the target current is 20.0 amps and you want to apply 50% throttle for this setpoint then the feed forward gain would be set to (0.50×32767)/20.0=819.175. Convert this to fixed-point by multiplying by 65536. This results in a value of 0x03332CCC (hex), which is what should be sent to the DMC60 in the value field of the PARAMSET packet. The feed-forward term can be excluded from the PID calculations by specifying a value of 0 for the gain. This parameter will be utilized for PID calculations when motor control profile slot 1 is specified in a control frame that specifies one of the closed loop control modes (Velocity, Position, or Current). This parameter is stored in nonvolatile memory and is preserved across power cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to configure. </td></tr>
    <tr><td class="paramname">value</td><td>F gain value to assign. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a68b3250aa373f7d310783e7823bb3fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b3250aa373f7d310783e7823bb3fb8">&#9670;&nbsp;</a></span>get_kF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::get_kF </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the F gain value of the specified slot and stores the value into a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to read. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to store value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="af2dc8ad4712d5ea17dfff8649e7ed37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2dc8ad4712d5ea17dfff8649e7ed37e">&#9670;&nbsp;</a></span>configPID_IZone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configPID_IZone </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the integral accumulator limit used by motor control profile slot 0. The integral accumulator limit, or I-zone, is used to limit how large the integral accumulator can grow during closed loop control. The value sent to the DMC60 is converted to a 32-bit signed integer and used to set the positive and negative bounds of the integral accumulator. If the integral accumulator exceeds these bounds while PID calculations are performed, then the accumulator will be capped to value or -value. This provides a mechanism for combating integral windup. Setting a value of 0 will disable the limit and allow the integral accumulator to grow without bounds. This parameter is stored in nonvolatile memory and is preserved across power cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to configure. </td></tr>
    <tr><td class="paramname">value</td><td>Izone value to assign. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ad5bb041176db71fb4150f08acef7d7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bb041176db71fb4150f08acef7d7ca">&#9670;&nbsp;</a></span>get_IZone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::get_IZone </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current Izone value stored in the specified PID slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to configure. </td></tr>
    <tr><td class="paramname">value</td><td>Buffer to store Izone value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a42175c4ddb198b062283e8d90c8727ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42175c4ddb198b062283e8d90c8727ae">&#9670;&nbsp;</a></span>configPID_AllowableError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configPID_AllowableError </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the allowable closed loop error used by the specified motor control profile slot. The allowable closed loop error specifies the minimum error required for the PID controller to calculate a non-zero contribution to the output throttle (duty cycle) based on the P, I, and D terms. If the allowable error is set to a non-zero value and the measured error is less than the allowable error then the P, I, and D terms will contribute 0 throttle units to the output throttle calculation and the integral accumulator will be cleared. If the allowable error is set to 0 or the measured error exceeds the allowable error then P, I, and D terms are included in the output throttle calculation. The feed-forward gain constant, or F term, is included in the output throttle calculation regardless of the allowable error setting. This parameter will be utilized for PID calculations when motor control profile slot 1 is specified in a control frame that specifies one of the closed loop control modes (Velocity, Position, or Current). This parameter is stored in nonvolatile memory and is preserved across power cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to configure. </td></tr>
    <tr><td class="paramname">value</td><td>Allowable closed loop error. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ac470a2fbff00fef6783131d0c70f2efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac470a2fbff00fef6783131d0c70f2efd">&#9670;&nbsp;</a></span>getPID_AllowableError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getPID_AllowableError </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the allowable error value stored in the specified PID slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>PID slot to configure. </td></tr>
    <tr><td class="paramname">value</td><td>Buffer to store the allowable error value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="afe9d7e3e415bf7e0326f87b017f11e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9d7e3e415bf7e0326f87b017f11e49">&#9670;&nbsp;</a></span>configForwardLimitSwitchEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configForwardLimitSwitchEnable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not the forward limit switch is enabled or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True if enabled, false if not. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ac54ec2b582813688861a64ddec6afb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54ec2b582813688861a64ddec6afb89">&#9670;&nbsp;</a></span>getForwardLimitSwitchEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getForwardLimitSwitchEnable </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets whether or not the forward limit switch is enabled or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Pointer to store the enabled value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a3ce3872ba40adf4290ba5640236d2402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce3872ba40adf4290ba5640236d2402">&#9670;&nbsp;</a></span>configForwardLimitSwitchType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configForwardLimitSwitchType </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normallyClosed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the switch type of the forward limit switch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normallyClosed</td><td>False if the switch is normally opened, true if normally closed. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ae59b0a6c9c06159cf5bafa76dba35ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59b0a6c9c06159cf5bafa76dba35ab5">&#9670;&nbsp;</a></span>getForwardLimitSwitchType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getForwardLimitSwitchType </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>normallyClosed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the switch type of the forward limit switch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normallyClosed</td><td>Pointer to store the switch type value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ad8465082309c0ff51a0d6322f252cd7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8465082309c0ff51a0d6322f252cd7a">&#9670;&nbsp;</a></span>configReverseLimitSwitchEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configReverseLimitSwitchEnable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not the reverse limit switch is enabled or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True if enabled, false if not. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="acc1f29a8572547a18d343d0a192f67d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1f29a8572547a18d343d0a192f67d6">&#9670;&nbsp;</a></span>getReverseLimitSwitchEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getReverseLimitSwitchEnable </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets whether or not the reverse limit switch is enabled or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Pointer to store the enabled value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a09bb7f1045f130b5a79b7bc02a8c611e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09bb7f1045f130b5a79b7bc02a8c611e">&#9670;&nbsp;</a></span>configReverseLimitSwitchType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configReverseLimitSwitchType </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normallyClosed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the switch type of the reverse limit switch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normallyClosed</td><td>False if the switch is normally opened, true if normally closed. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a979429b016f5ce3b6d8b0551cd8db329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979429b016f5ce3b6d8b0551cd8db329">&#9670;&nbsp;</a></span>getReverseLimitSwitchType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getReverseLimitSwitchType </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>normallyClosed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the switch type of the reverse limit switch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normallyClosed</td><td>Pointer to store the switch type value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ab3b9d47a1de502bb8a653a54fae4639b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b9d47a1de502bb8a653a54fae4639b">&#9670;&nbsp;</a></span>configSoftFwdThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configSoftFwdThreshold </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the soft forward limit threshold. The soft forward limit threshold specifies the maximum position that the encoder can read in the forward direction. The units are native to the encoder thats connected to the expansion header. The DMC60s control loop runs every 500us. Each time it executes the current position of the encoder is read and compared to the soft forward limit threshold. If the encoders current position is greater than or equal to the specified soft forward limit threshold and the soft forward limit is enabled, then the DMC60s output will be prevented from applying a positive voltage to the load. Both positive and negative soft limit thresholds are valid. This parameter is stored in nonvolatile memory and is preserved across power cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enables or disables the forward soft limit. </td></tr>
    <tr><td class="paramname">limit</td><td>Soft forward limit threshold. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a37c10dd21de40c0f19e3149e06e7e078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c10dd21de40c0f19e3149e06e7e078">&#9670;&nbsp;</a></span>getSoftFwdThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getSoftFwdThreshold </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current soft forward threshold value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Buffer to store the enabled bit. </td></tr>
    <tr><td class="paramname">limit</td><td>Buffer to store the limit value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a14b4df6835e63f2839aa7b9a0b97324b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b4df6835e63f2839aa7b9a0b97324b">&#9670;&nbsp;</a></span>configSoftRevThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configSoftRevThreshold </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the reverse limit switch type. The reverse limit switch be configured as a normally closed switch by setting the value field to a 1 or a normally open switch by setting the value field to a 0. The DMC60 uses internal (weak) pull-ups to pull the reverse limit switch pin to 3.3V. When configured as a normally closed switch the DMC60 will prevent the output from applying a negative voltage to the load when the limit switch opens, causing the DMC60 to detect a logic 1 on the REVLIM pin. When configured as a normally open switch the DMC60 will prevent the output from applying a negative voltage to the load when the limit switch closes, causing the DMC60 to detect a logic 0 on the REVLIM pin. This parameter is stored in nonvolatile memory and is preserved across power cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enables or disables the reverse soft limit. </td></tr>
    <tr><td class="paramname">limit</td><td>Soft reverse limit threshold. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a38cfae410c8f0831ce0fb573965b7c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cfae410c8f0831ce0fb573965b7c12">&#9670;&nbsp;</a></span>getSoftRevThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getSoftRevThreshold </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current soft reverse threshold value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Buffer to store the enabled bit. </td></tr>
    <tr><td class="paramname">limit</td><td>Buffer to store the limit value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a8bcb3e97d51333936d557bff99cae6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcb3e97d51333936d557bff99cae6f4">&#9670;&nbsp;</a></span>configAnalogStatusFramePeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configAnalogStatusFramePeriod </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>periodMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the rate at which the DMC60 transmits Analog Input, Current, Temperature, and Battery Voltage Status Frames. These status frames are formatted as STSANALOG packets and are described in the Periodic Status Messages section. The frame rate can be set to any value between 1 millisecond and 30000 milliseconds. Power cycling the DMC60 will result in the device reverting to the default frame rate, which is 100 milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">periodMs</td><td>Frame period in milliseconds. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a659311773a28f913a56ce14e9f662b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659311773a28f913a56ce14e9f662b15">&#9670;&nbsp;</a></span>getAnalogStatusFramePeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getAnalogStatusFramePeriod </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>periodMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current analog status frame period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">periodMs</td><td>Buffer to store the period. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a1e935d2b29ff546602d1b84e6f8f97b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e935d2b29ff546602d1b84e6f8f97b8">&#9670;&nbsp;</a></span>configEncoderStatusFramePeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configEncoderStatusFramePeriod </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>periodMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the rate at which the DMC60 transmits Quadrature Encoder Status Frames. These status frames are formatted as STSENCODER packets and are described in the Periodic Status Messages section. The frame rate can be set to any value between 1 millisecond and 30000 milliseconds. Power cycling the DMC60 will result in the device reverting to the default frame rate, which is 100 milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">periodMs</td><td>Frame period in milliseconds. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="aefb92935ec7d2a4f6b66de7230a66e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb92935ec7d2a4f6b66de7230a66e2f">&#9670;&nbsp;</a></span>getEncoderStatusFramePeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getEncoderStatusFramePeriod </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>periodMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current encoder status frame period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">periodMs</td><td>Buffer to store the period. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ac36016b56320decf83bea78a4aa183e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36016b56320decf83bea78a4aa183e2">&#9670;&nbsp;</a></span>configGeneralStatusFramePeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::configGeneralStatusFramePeriod </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>periodMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the rate at which the DMC60 transmits General Status Frames. These status frames are formatted as STSGENERAL packets and are described in the Periodic Status Messages section. The frame rate can be set to any value between 1 millisecond and 30000 milliseconds. Power cycling the DMC60 will result in the device reverting to the default frame rate, which is 10 milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">periodMs</td><td>Frame period in milliseconds. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a692c4796494a84f5555cc1b57c6a9c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692c4796494a84f5555cc1b57c6a9c42">&#9670;&nbsp;</a></span>getGeneralStatusFramePeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getGeneralStatusFramePeriod </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>periodMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current general status frame period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">periodMs</td><td>Buffer to store the period. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a90c9af872e64be9c5049580001bdc8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c9af872e64be9c5049580001bdc8a9">&#9670;&nbsp;</a></span>setEncoderPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::setEncoderPosition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the encoder position. The encoder position is maintained by the QEI module of the DMC60s MCU and is continuously updated by the pulse train applied to QEA and QEB inputs of the expansion header. At power on the encoders position is initialized to zero. This may not correspond with the zero point thats defined in the end user application, and as such, it may be necessary to set the encoder to a specific position or reset it to 0 after performing a homing sequence. The encoders position is used for closed loop position control and for determining whether the forward soft limit or reverse soft limit have been hit. The encoder position should only be configured while the DMC60s output is disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>32 bit signed encoder position. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a5fdd853858f2b702a3b6b148e2f5c969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fdd853858f2b702a3b6b148e2f5c969">&#9670;&nbsp;</a></span>getEncoderPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getEncoderPosition </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the encoder position. The encoder position is maintained by the QEI module of the DMC60s MCU and is continuously updated by the pulse train applied to QEA and QEB inputs of the expansion header. At power on the encoders position is initialized to zero. This may not correspond with the zero point thats defined in the end user application, and as such, it may be necessary to set the encoder to a specific position or reset it to 0 after performing a homing sequence. The encoders position is used for closed loop position control and for determining whether the forward soft limit or reverse soft limit have been hit. The encoder position should only be configured while the DMC60s output is disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*position</td><td>Integer to store position. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a13a8f0a5a64b9dfab92441da2af4bcc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a8f0a5a64b9dfab92441da2af4bcc4">&#9670;&nbsp;</a></span>setClearPositionOnIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::setClearPositionOnIndex </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not the index pin will cause the position count to reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable position count reset on active edge of index. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a2fedb67253fcf6ce76b890b04177064b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fedb67253fcf6ce76b890b04177064b">&#9670;&nbsp;</a></span>getClearPositionOnIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getClearPositionOnIndex </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets whether or not the index pin will cause the position count to reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Buffer to store the result. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a3bb65e5fe38e93f88e54a1ff88c2e3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb65e5fe38e93f88e54a1ff88c2e3be">&#9670;&nbsp;</a></span>setClearPositionOnFwdLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::setClearPositionOnFwdLimit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not the forward limit switch pin will cause the position count to reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable position count reset on active edge of fwd limit switch. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a1f1f241c12e126b49bd228f0bd3944d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1f241c12e126b49bd228f0bd3944d1">&#9670;&nbsp;</a></span>getClearPositionOnFwdLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getClearPositionOnFwdLimit </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets whether or not the fwd limit switch pin will cause the position count to reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Buffer to store the result. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a6b71a242b0be616396d9ade17364096d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b71a242b0be616396d9ade17364096d">&#9670;&nbsp;</a></span>setClearPositionOnRevLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::setClearPositionOnRevLimit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not the reverse limit switch pin will cause the position count to reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable position count reset on active edge of rev limit switch. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="afb2481131750ba67b4bf1ca293426606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2481131750ba67b4bf1ca293426606">&#9670;&nbsp;</a></span>getClearPositionOnRevLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getClearPositionOnRevLimit </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets whether or not the reverse limit switch pin will cause the position count to reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Buffer to store the result. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a3036f6d918200a53b435ec965ac1384f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3036f6d918200a53b435ec965ac1384f">&#9670;&nbsp;</a></span>setIndexActiveEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::setIndexActiveEdge </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the active edge of the index pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>True for rising edge, false for falling edge. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a052f47cd6fafa996eb5f443ea130abab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052f47cd6fafa996eb5f443ea130abab">&#9670;&nbsp;</a></span>getIndexActiveEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getIndexActiveEdge </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the active edge of the index pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>Buffer to store the result. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ab23c199980033facc445efc876aab41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23c199980033facc445efc876aab41a">&#9670;&nbsp;</a></span>resetStickyFaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::resetStickyFaults </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the counts stored in the sticky faults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a6068613835ef3a23b43f618bfdc7abed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6068613835ef3a23b43f618bfdc7abed">&#9670;&nbsp;</a></span>resetOverTempStickyFaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::resetOverTempStickyFaults </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the overtemp sticky fault count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="aedc39a79eec7762e7c20686ce1598863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc39a79eec7762e7c20686ce1598863">&#9670;&nbsp;</a></span>resetOverCurrentStickyFaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::resetOverCurrentStickyFaults </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the overcurrent sticky fault count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a6193038b50da23806cb5afa54a4377bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6193038b50da23806cb5afa54a4377bb">&#9670;&nbsp;</a></span>resetUnderVoltageStickyFaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::resetUnderVoltageStickyFaults </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the undervoltage sticky fault count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="afe9b502f306e9dcb02b227354a602fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9b502f306e9dcb02b227354a602fd1">&#9670;&nbsp;</a></span>resetGateDriverStickyFaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::resetGateDriverStickyFaults </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the gate driver sticky fault count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ae25446adf38e99edaf8ffb1bddf000b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25446adf38e99edaf8ffb1bddf000b9">&#9670;&nbsp;</a></span>resetCommStickyFaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::resetCommStickyFaults </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the comm sticky fault count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ac06083d8ee1fb496e33771aa088a1790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06083d8ee1fb496e33771aa088a1790">&#9670;&nbsp;</a></span>getActiveFaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getActiveFaults </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the active fault bit field from the motor controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Buffer to store the active faults into. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a83c86504442287cb0a9b1b82dd6bd5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c86504442287cb0a9b1b82dd6bd5af">&#9670;&nbsp;</a></span>getStickyFaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getStickyFaults </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the sticky fault bit field from the motor controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Buffer to store the sticky faults into. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ab82ad817300e14bc64a009c60723489c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82ad817300e14bc64a009c60723489c">&#9670;&nbsp;</a></span>getOverTempStickyFaultCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getOverTempStickyFaultCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the number of over temp sticky faults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Buffer to store the number into. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ad959714e50976d38b7e99158bddc35ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad959714e50976d38b7e99158bddc35ef">&#9670;&nbsp;</a></span>getOverCurrentStickyFaultCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getOverCurrentStickyFaultCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the number of over current sticky faults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Buffer to store the number into. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ad7345700ee674050b236f0b979068a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7345700ee674050b236f0b979068a4a">&#9670;&nbsp;</a></span>getUnderVoltageStickyFaultCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getUnderVoltageStickyFaultCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the number of under voltage sticky faults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Buffer to store the number into. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a934ac1fa07a46eb0e5fdaa347d2b8f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934ac1fa07a46eb0e5fdaa347d2b8f24">&#9670;&nbsp;</a></span>getGateDriverStickyFaultCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getGateDriverStickyFaultCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the number of gate driver sticky faults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Buffer to store the number into. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ab91c8552ff86e600e24796fe9ffa23b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91c8552ff86e600e24796fe9ffa23b5">&#9670;&nbsp;</a></span>getCommStickyFaultCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getCommStickyFaultCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the number of comm sticky faults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Buffer to store the number into. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a81b37d792f50128266d554b676647dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b37d792f50128266d554b676647dac">&#9670;&nbsp;</a></span>setOverrideBC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMC60LowLevel::setOverrideBC </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>brakecoast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the brake/coast mode override. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enable the override. </td></tr>
    <tr><td class="paramname">brakecoast</td><td>0: Coast when neutral throttle is applied 1: Brake when neutral throttle is applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51af9c56d6adc211c8e7626b70f486ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51af9c56d6adc211c8e7626b70f486ce">&#9670;&nbsp;</a></span>setReverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMC60LowLevel::setReverse </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the reverse bit in control0 frame. This causes the motor controller to reverse drive of the motor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reverse</td><td>true = Reversed, false = Not reversed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a116ed15cc29bfa08b30650b71ca33c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116ed15cc29bfa08b30650b71ca33c34">&#9670;&nbsp;</a></span>setLimitSwitchOverride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMC60LowLevel::setLimitSwitchOverride </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forwardSwitchEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverseSwitchEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the override bits in the control frame. This overrides the limit switch parameters to allow enabling and disabling the limit switches realtime,. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enables the override. </td></tr>
    <tr><td class="paramname">forwardSwitchEnable</td><td>True = Enable forward limit switch when override is enabled. False = Disable forward limit switch when override is enabled. </td></tr>
    <tr><td class="paramname">reverseSwitchEnable</td><td>True = Enable reverse limit switch when override is enabled. False = Disable reverse limit switch when override is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90adc44cfd52bc13e9f122bd76292315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90adc44cfd52bc13e9f122bd76292315">&#9670;&nbsp;</a></span>setReverseFeedbackSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMC60LowLevel::setReverseFeedbackSensor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the reverse bit in control0 frame. This causes the motor controller to reverse drive of the motor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reverse</td><td>true = Reversed, false = Not reversed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40e393a2aba7209f35655608dc8cc154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e393a2aba7209f35655608dc8cc154">&#9670;&nbsp;</a></span>setRampRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMC60LowLevel::setRampRate </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>rampRate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the open loop ramp rate that is sent within each control0 frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rampRate</td><td>The open loop ramp rate. The lower it is, the slower it will ramp. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3139ed564a30ee256daa100c9e8fc45a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3139ed564a30ee256daa100c9e8fc45a">&#9670;&nbsp;</a></span>sendControl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMC60LowLevel::sendControl </td>
          <td>(</td>
          <td class="paramtype">ControlMode&#160;</td>
          <td class="paramname"><em>Mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>trgt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the control0 frame with the specified parameters at a specified period. This is the main control of the DMC60C. This frame must be sent every 104ms or the DMC60C will go into standby mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mode</td><td>The control mode. </td></tr>
    <tr><td class="paramname">trgt</td><td>The target setpoint of the specified control mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae40de1cac1cf8f2011b1bd78131f5a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40de1cac1cf8f2011b1bd78131f5a9d">&#9670;&nbsp;</a></span>sendControl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMC60LowLevel::sendControl </td>
          <td>(</td>
          <td class="paramtype">ControlMode&#160;</td>
          <td class="paramname"><em>Mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>trgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ramp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>periodMs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the control0 frame with the specified parameters at a specified period. This is the main control of the DMC60C. This frame must be sent every 104ms or the DMC60C will go into standby mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mode</td><td>The control mode. </td></tr>
    <tr><td class="paramname">trgt</td><td>The target setpoint of the specified control mode. </td></tr>
    <tr><td class="paramname">ramp</td><td>The open loop ramp rate (not applicable in closed loop mode). </td></tr>
    <tr><td class="paramname">periodMs</td><td>The period to send the control0 frame at. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a312dfdcde2079a12157e5d7c39b577a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312dfdcde2079a12157e5d7c39b577a8">&#9670;&nbsp;</a></span>getAnalogStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getAnalogStatus </td>
          <td>(</td>
          <td class="paramtype">STSANALOG *&#160;</td>
          <td class="paramname"><em>stsAnalogOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the latest STSANALOG frame from the DMC60C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stsAnalogOut</td><td>Pointer to STSANALOG buffer to store data into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a81187bef46e108590fd02ed019c6adbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81187bef46e108590fd02ed019c6adbe">&#9670;&nbsp;</a></span>getEncoderStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getEncoderStatus </td>
          <td>(</td>
          <td class="paramtype">STSENCODER *&#160;</td>
          <td class="paramname"><em>stsEncoderOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the latest STSENCODER frame from the DMC60C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stsEncoderOut</td><td>Pointer to STSENCODER buffer to store data into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="ae5f050cdd3671f10149459d24449726a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f050cdd3671f10149459d24449726a">&#9670;&nbsp;</a></span>getGeneralStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getGeneralStatus </td>
          <td>(</td>
          <td class="paramtype">STSGENERAL *&#160;</td>
          <td class="paramname"><em>stsGeneralOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the latest STSGENERAL frame from the DMC60C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stsGeneralOut</td><td>Pointer to STSGENERAL buffer to store data into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="aff33401f4a821c4628317cb9cf2e355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff33401f4a821c4628317cb9cf2e355d">&#9670;&nbsp;</a></span>SetControlMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DMC60LowLevel::SetControlMode </td>
          <td>(</td>
          <td class="paramtype">ControlMode&#160;</td>
          <td class="paramname"><em>Mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the ControlMode in the control0 frame. The frame must be resent with <a class="el" href="class_d_m_c60_low_level.html#a7f7c86f7e7a23dbb33a9bf62de933389" title="Resends the control0 frame. If it has not been sent before, it will start sending the default _contro...">sendControl()</a> to have any effect, although this is not recommended in most cases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mode</td><td>Control mode to set to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7191ed017cb067d031edbfd05e406922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7191ed017cb067d031edbfd05e406922">&#9670;&nbsp;</a></span>GetControlMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ControlMode DMC60LowLevel::GetControlMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current controlMode in the control0 frame. </p>
<dl class="section return"><dt>Returns</dt><dd>The current control mode. </dd></dl>

</div>
</div>
<a id="a8588d024d1b45efb197f6a0345ae8d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8588d024d1b45efb197f6a0345ae8d77">&#9670;&nbsp;</a></span>setContinuousCurrentLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::setContinuousCurrentLimit </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>currentAmps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the continuous current limit. This applies only if current limiting is enabled. The continuous current limit is the maximum current that can be drawn by the DMC60C AFTER the peak current limit has been hit for the peak current duration. If the continuous current limit is greater than or equal to the peak current limit, then the DMC60C will begin limiting the current immediately after the continuous current limit is exceeded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentAmps</td><td>The continuous current limit to set in amps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DMC_Code Status code. </dd></dl>

</div>
</div>
<a id="af0e6ccb82d52958b882a55e33ce0d94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e6ccb82d52958b882a55e33ce0d94a">&#9670;&nbsp;</a></span>getContinuousCurrentLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getContinuousCurrentLimit </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>currentAmps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the continuous current limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentAmps</td><td>Buffer to store the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DMC_Code Status code. </dd></dl>

</div>
</div>
<a id="a4b4ba39501eceb139d71e28b5b7e51f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4ba39501eceb139d71e28b5b7e51f2">&#9670;&nbsp;</a></span>setPeakCurrentLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::setPeakCurrentLimit </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>currentAmps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the peak current limit. This only applies if current limiting is enabled. The peak current is the max current that can be applied to the motor at any given time. This limit can be applied for up to [peak current duration] milliseconds. Afterwards the continuous current limit will be applied. If the peak current limit is set to a value lower than the continuous current limit, the DMC60C will apply the continuous current limit immediately after it detects that the continuous current limit has been exceeded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentAmps</td><td>The peak current limit to set in amps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DMC_Code Status code. </dd></dl>

</div>
</div>
<a id="ad886c016dd702d04393512096c9a1abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad886c016dd702d04393512096c9a1abd">&#9670;&nbsp;</a></span>getPeakCurrentLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getPeakCurrentLimit </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>currentAmps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the peak current limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentAmps</td><td>Buffer to store the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DMC_Code Status code. </dd></dl>

</div>
</div>
<a id="a14e00b7a7a2e812a21507222bced95cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e00b7a7a2e812a21507222bced95cb">&#9670;&nbsp;</a></span>setPeakCurrentDuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::setPeakCurrentDuration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>durationMs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the peak current duration. This only applies if current limiting is enabled. The peak current duration is the maximum amount of time the peak current can be applied to the motor. After this duration, the continuous current limit will be applied. If the duration is set to 0, the DMC60C will begin applying the continuous current limit immediately after the peak current limit has been exceeded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">durationMs</td><td>The peak current duration in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DMC_Code Status code. </dd></dl>

</div>
</div>
<a id="ae5eae9514bed579e3ea8fbb108f5de08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5eae9514bed579e3ea8fbb108f5de08">&#9670;&nbsp;</a></span>getPeakCurrentDuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getPeakCurrentDuration </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>durationMs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the peak current duration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">durationMs</td><td>Buffer to store the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DMC_Code Status code. </dd></dl>

</div>
</div>
<a id="aabbf7d0c4df2d937090f01532bdfd3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbf7d0c4df2d937090f01532bdfd3a0">&#9670;&nbsp;</a></span>enableCurrentLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::enableCurrentLimit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables current limiting mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>If true, enabled current limiting. If false, disables current limiting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DMC_Code Status code. </dd></dl>

</div>
</div>
<a id="a43dbcc1679007594265f6b7a005344e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43dbcc1679007594265f6b7a005344e6">&#9670;&nbsp;</a></span>setADCMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::setADCMultiplier </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the constant used by the DMC60 to convert ADC measurements into an associated load current in amps. The DMC60 uses a combination of a current sense resistor, bidirectional current sense amplifier with a 50V/V gain, and a 3.3V reference to measure load currents. The current sense amplifier is biased at 1.65V, which means a load current of 0 amps will result in the current sense amplifier outputting 1.65V. At power on the DMC60 performs a calibration procedure to determine the ADC sample value (smpZeroCurrent) corresponding to no current flow between the M+ and M- terminals. When current flows from the M+ terminal to the M- terminal the current sense amplifier outputs a voltage between 1.65V and 3.3V, which corresponds to positive current flow. When current flows from the M- terminal to the M+ terminal the current sense amplifier outputs a voltage between 1.65V and 0V, corresponding to negative current flow. The DMC60 uses an internal 12-bit ADC to convert this voltage into digitized value every 500 microseconds. The digitized value is then converted into a signed 16.6 fixed point current measurement (in Amps) using the following formula: crntLoad=(smpAdc-smpZeroCurrent)×mplrAdcCurrent. The multiplier (mplrAdcCurrent) that corresponds to a given sense resistance (resCrntSns, in ohms) can be calculated using the following formula: mplrAdcCurrent=(vref/4096×1/(resCrntSns×50))×65536. For example, if the sense resistor has a nominal value of 500 µohms then the mplrAdcCurrent=(3.3/4096×1/(0.0005×50))×65536=2112 or 0x00000840 in hexadecimal. The DMC60 comes pre-programmed with a multiplier that corresponds to the expected sense resistance (approximately 510 µohms) so it should not be necessary to configure the multiplier. However, if current measurements appear to be off then paramAdcCurrentMultiplier can be used to adjust the multiplier used. This parameter is stored in nonvolatile memory and is preserved across power cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Signed 16.16 value to set the ADC Multiplier to </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="aed36e81f958ed8189f444f2f198b4b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed36e81f958ed8189f444f2f198b4b2f">&#9670;&nbsp;</a></span>getADCMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::getADCMultiplier </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmsWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the currently stored value for. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Buffer to store the value. </td></tr>
    <tr><td class="paramname">tmsWait</td><td>Max time in milliseconds to wait for a response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
<a id="a4284f8a0e841a13a23bdda94c58bad40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4284f8a0e841a13a23bdda94c58bad40">&#9670;&nbsp;</a></span>enterBootloader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DMC_Code DMC60LowLevel::enterBootloader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the DMC60C into bootloader mode. </p>
<dl class="section return"><dt>Returns</dt><dd>Status code. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_d_m_c60_low_level.html">DMC60LowLevel</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
